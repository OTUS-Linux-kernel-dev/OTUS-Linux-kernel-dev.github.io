<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Ts - OTUS-linux-kernel-dev</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Ts";
        var mkdocs_page_input_path = "ts.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> OTUS-linux-kernel-dev
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../task_struct/">Process</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">OTUS-linux-kernel-dev</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Ts</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <p>Структура <code>task_struct</code> в ядре Linux — это фундаментальная структура данных, описывающая процесс или поток (нить). Она содержит всю информацию, необходимую ядру для управления задачами: состояние выполнения, идентификаторы, ресурсы, планирование и многое другое. Ниже приведено подробное описание её ключевых полей и их назначения.</p>
<hr />
<h3 id="task_struct"><strong>Основные компоненты <code>task_struct</code></strong></h3>
<p>Структура определена в файле <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h"><code>include/linux/sched.h</code></a> и постоянно развивается. Рассмотрим основные группы полей.</p>
<hr />
<h4 id="1"><strong>1. Идентификаторы процесса</strong></h4>
<p>Поля, связанные с идентификаторами, позволяют ядру однозначно определять процессы и управлять их группами:</p>
<h5 id="pid_t-pid"><strong><code>pid_t pid</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Уникальный идентификатор процесса (Process ID).</li>
<li><strong>Особенности</strong>:</li>
<li>При создании процесса через <code>fork()</code> или <code>clone()</code> ядро выделяет новый <code>pid</code>.</li>
<li>Для потоков (нитей) в многопоточном приложении каждый поток имеет свой уникальный <code>pid</code>, но общий <code>tgid</code> (см. ниже).</li>
<li>PID 1 обычно присваивается процессу <code>init</code> (или <code>systemd</code> в современных системах).</li>
</ul>
<h5 id="pid_t-tgid-thread-group-id"><strong><code>pid_t tgid</code></strong> (Thread Group ID)</h5>
<ul>
<li><strong>Назначение</strong>: Идентификатор группы потоков. </li>
<li><strong>Особенности</strong>:</li>
<li>Для <strong>однопоточного</strong> процесса <code>pid == tgid</code>.</li>
<li>Для <strong>многопоточного</strong> приложения все потоки имеют одинаковый <code>tgid</code>, равный <code>pid</code> основного потока (того, который был создан первым).</li>
<li>Системные вызовы <code>getpid()</code> возвращают именно <code>tgid</code>, чтобы пользовательское пространство видело группу потоков как единый процесс.</li>
</ul>
<h5 id="struct-task_struct-group_leader"><strong><code>struct task_struct *group_leader</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Указатель на "лидера" группы потоков.</li>
<li><strong>Особенности</strong>:</li>
<li>Для многопоточного приложения <code>group_leader</code> указывает на <code>task_struct</code> основного потока.</li>
<li>При завершении лидера все потоки группы получают сигнал <code>SIGHUP</code> (если не настроено иное).</li>
</ul>
<hr />
<h4 id="2"><strong>2. Состояние процесса</strong></h4>
<h5 id="volatile-long-state"><strong><code>volatile long state</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Текущее состояние задачи. Определяет, может ли процесс быть выбран планировщиком для выполнения.</li>
<li><strong>Возможные значения</strong>:</li>
<li><strong><code>TASK_RUNNING</code></strong>:<ul>
<li>Процесс готов к выполнению (стоит в очереди планировщика) или уже выполняется.</li>
</ul>
</li>
<li><strong><code>TASK_INTERRUPTIBLE</code></strong>:<ul>
<li>Процесс ожидает события (например, данных из сокета или завершения системного вызова).</li>
<li><strong>Может быть прерван сигналом</strong> (например, <code>SIGKILL</code>). После получения сигнала процесс переходит в <code>TASK_RUNNING</code> и обрабатывает его.</li>
</ul>
</li>
<li><strong><code>TASK_UNINTERRUPTIBLE</code></strong>:<ul>
<li>Процесс ожидает события, но <strong>не реагирует на сигналы</strong> (используется для критических операций, таких как доступ к диску).</li>
<li>Пример: чтение данных с повреждённого диска, где прерывание может привести к неконсистентности.</li>
</ul>
</li>
<li><strong><code>__TASK_STOPPED</code></strong>:<ul>
<li>Процесс остановлен внешним сигналом (например, <code>SIGSTOP</code> или отладчиком). Возобновляется сигналом <code>SIGCONT</code>.</li>
</ul>
</li>
<li><strong><code>EXIT_ZOMBIE</code></strong>:<ul>
<li>Процесс завершился, но его родитель ещё не вызвал <code>wait()</code>, чтобы получить код завершения. В этом состоянии процесс уже не использует ресурсы, кроме <code>task_struct</code>.</li>
</ul>
</li>
<li><strong><code>EXIT_DEAD</code></strong>:<ul>
<li>Финальное состояние перед удалением <code>task_struct</code> из системы (после вызова <code>wait()</code> родителем).</li>
</ul>
</li>
</ul>
<h5 id="int-exit_state"><strong><code>int exit_state</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Дополнительные флаги завершения процесса.</li>
<li><strong>Примеры значений</strong>:</li>
<li><code>EXIT_ZOMBIE</code>: Процесс завершился, но родитель ещё не обработал его.</li>
<li><code>EXIT_DEAD</code>: Процесс полностью удалён из системы.</li>
</ul>
<hr />
<h4 id="3"><strong>3. Связи между процессами</strong></h4>
<ul>
<li><strong><code>struct task_struct *parent</code></strong>: Указатель на родительский процесс.</li>
<li><strong><code>struct list_head children</code></strong>: Список дочерних процессов.</li>
<li><strong><code>struct list_head sibling</code></strong>: Список "братьев" (процессы с тем же родителем).</li>
<li><strong><code>struct list_head tasks</code></strong>: Элемент глобального списка всех задач.</li>
</ul>
<hr />
<h4 id="4"><strong>4. Планирование и время</strong></h4>
<ul>
<li><strong><code>int prio</code></strong>: Динамический приоритет (учитывает "nice" и поведение).</li>
<li><strong><code>int static_prio</code></strong>: Статический приоритет (значение <code>nice</code> от -20 до 19).</li>
<li><strong><code>const struct sched_class *sched_class</code></strong>: Класс планировщика (например, <code>SCHED_NORMAL</code>, <code>SCHED_FIFO</code>).</li>
<li><strong><code>struct sched_entity se</code></strong>: Данные для планировщика CFS (Completely Fair Scheduler).</li>
<li><strong><code>u64 utime</code></strong>, <strong><code>u64 stime</code></strong>: Время выполнения в пользовательском и системном режиме.</li>
<li><strong><code>unsigned long start_time</code></strong>: Время создания процесса.</li>
</ul>
<hr />
<h4 id="5"><strong>5. Управление памятью</strong></h4>
<h5 id="struct-mm_struct-mm"><strong><code>struct mm_struct *mm</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Указатель на структуру, описывающую виртуальную память процесса.</li>
<li><strong>Содержимое <code>mm_struct</code></strong>:</li>
<li>Таблица страниц (Page Table) — преобразует виртуальные адреса в физические.</li>
<li>Список областей памяти (VMA — Virtual Memory Areas): сегменты кода, данных, стека, кучи, разделяемых библиотек.</li>
<li>Информация о сегментах (например, <code>start_code</code>, <code>end_data</code>).</li>
<li><strong>Особенности</strong>:</li>
<li>Для <strong>пользовательских процессов</strong> <code>mm</code> всегда валиден.</li>
<li><strong>Потоки ядра</strong> (например, kthreadd) не имеют пользовательского адресного пространства, поэтому <code>mm == NULL</code>.</li>
</ul>
<h5 id="struct-mm_struct-active_mm"><strong><code>struct mm_struct *active_mm</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Активное виртуальное адресное пространство, используемое процессором в данный момент.</li>
<li><strong>Особенности</strong>:</li>
<li>Для <strong>пользовательских процессов</strong> <code>active_mm == mm</code>.</li>
<li>Для <strong>потоков ядра</strong>:<ul>
<li>При переключении контекста поток ядра "заимствует" <code>active_mm</code> у предыдущего пользовательского процесса (чтобы не переключать таблицы страниц без необходимости).</li>
<li>Например, если поток ядра выполняется после пользовательского процесса, он использует его <code>active_mm</code>, но не имеет доступа к пользовательской памяти.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="6"><strong>6. Файлы и файловая система</strong></h4>
<ul>
<li><strong><code>struct files_struct *files</code></strong>: Таблица открытых файлов.</li>
<li><strong><code>struct fs_struct *fs</code></strong>: Информация о текущей рабочей и корневой директориях.</li>
</ul>
<hr />
<h4 id="7"><strong>7. Сигналы</strong></h4>
<ul>
<li><strong><code>struct signal_struct *signal</code></strong>: Общая информация о сигналах группы потоков.</li>
<li><strong><code>struct sighand_struct *sighand</code></strong>: Обработчики сигналов.</li>
<li><strong><code>sigset_t blocked</code></strong>: Маска заблокированных сигналов.</li>
<li><strong><code>struct sigpending pending</code></strong>: Ожидающие сигналы.</li>
</ul>
<hr />
<h4 id="8"><strong>8. Учётные данные и права доступа</strong></h4>
<ul>
<li><strong><code>const struct cred *cred</code></strong>: Учётные данные процесса (UID, GID, capabilities).</li>
<li><strong><code>struct cred *real_cred</code></strong>: Учётные данные на момент создания (неизменяемые).</li>
</ul>
<hr />
<h4 id="9"><strong>9. Потоки выполнения</strong></h4>
<h5 id="struct-thread_struct-thread"><strong><code>struct thread_struct thread</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Архитектурно-зависимые данные, сохраняющие состояние процессора при переключении контекста.</li>
<li><strong>Содержимое</strong> (зависит от архитектуры, например, для x86_64):</li>
<li>Регистры общего назначения (<code>rax</code>, <code>rbx</code>, <code>rcx</code> и т.д.).</li>
<li>Сегментные регистры (<code>cs</code>, <code>ds</code>, <code>ss</code>).</li>
<li>Регистр указателя стека (<code>rsp</code>).</li>
<li>Регистр флагов (<code>eflags</code>).</li>
<li>Регистры управления отладкой (<code>debugregs</code>).</li>
<li>Информация о FPU (состояние математического сопроцессора).</li>
<li><strong>Пример использования</strong>:</li>
<li>При переключении задач ядро сохраняет текущее состояние регистров в <code>thread</code> старой задачи и загружает состояние из <code>thread</code> новой задачи.</li>
</ul>
<h5 id="void-stack"><strong><code>void *stack</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Указатель на <strong>стек ядра</strong> процесса.</li>
<li><strong>Особенности</strong>:</li>
<li>Каждый процесс имеет два стека: <ul>
<li><strong>Стек пользователя</strong>: Используется при выполнении в пользовательском режиме.</li>
<li><strong>Стек ядра</strong>: Выделяется при входе в ядро (например, при системном вызове или прерывании). Именно на него указывает <code>stack</code>.</li>
</ul>
</li>
<li>Размер стека ядра фиксирован (обычно 8 КБ или 16 КБ, зависит от настройки ядра).</li>
<li>Для потоков ядра стек выделяется статически или динамически (например, через <code>vmalloc()</code>).</li>
</ul>
<hr />
<h4 id="10-namespaces"><strong>10. Пространства имён (Namespaces)</strong></h4>
<ul>
<li><strong><code>struct nsproxy *nsproxy</code></strong>: Указатель на пространства имён (PID, сеть, IPC и др.).</li>
</ul>
<hr />
<h4 id="11-cgroups"><strong>11. Контрольные группы (cgroups)</strong></h4>
<ul>
<li><strong><code>struct css_set *cgroups</code></strong>: Связь с контрольными группами для управления ресурсами.</li>
</ul>
<hr />
<h4 id="12"><strong>12. Сетевые параметры</strong></h4>
<ul>
<li><strong><code>struct nsproxy *net_ns</code></strong>: Сетевое пространство имён.</li>
<li><strong><code>struct files_struct *nsproxy</code></strong>: Сокеты и сетевые соединения.</li>
</ul>
<hr />
<h4 id="13"><strong>13. Отладка и трассировка</strong></h4>
<ul>
<li><strong><code>unsigned int ptrace</code></strong>: Флаги для ptrace (например, <code>PTRACE_TRACEME</code>).</li>
<li><strong><code>struct list_head ptrace_entry</code></strong>: Список для трассируемых процессов.</li>
</ul>
<hr />
<h4 id="14"><strong>14. Ресурсы и ограничения</strong></h4>
<ul>
<li><strong><code>struct rlimit rlim[RLIM_NLIMITS]</code></strong>: Ограничения ресурсов (макс. размер файла, CPU время и др.).</li>
<li><strong><code>struct rusage *rusage</code></strong>: Статистика использования ресурсов.</li>
</ul>
<hr />
<h4 id="15"><strong>15. Прочее</strong></h4>
<ul>
<li><strong><code>char comm[TASK_COMM_LEN]</code></strong>: Имя исполняемого файла (максимум 16 байт).</li>
<li><strong><code>int exit_code</code></strong>: Код завершения процесса.</li>
<li><strong><code>struct taskio_accounting ioac</code></strong>: Учёт операций ввода-вывода.</li>
</ul>
<hr />
<h3 id="_1"><strong>Важные замечания</strong></h3>
<ol>
<li><strong>Архитектурная зависимость</strong>: Некоторые поля (например, <code>thread_struct</code>) зависят от процессора.</li>
<li><strong>Версия ядра</strong>: Структура может меняться между версиями ядра. Для точности изучайте исходный код своей версии.</li>
<li><strong>Производительность</strong>: Поля часто оптимизируются для быстрого доступа (выравнивание, кэширование).</li>
<li><strong>Потоки vs. Процессы</strong>: В Linux нет отдельной структуры для потоков — все потоки представлены как <code>task_struct</code>, но с общими <code>mm</code>, <code>files</code>, <code>signal</code> и другими ресурсами.</li>
<li><strong>Состояние <code>TASK_UNINTERRUPTIBLE</code></strong>: Нельзя "убить" процесс в этом состоянии сигналом <code>SIGKILL</code> — он останется в этом состоянии, пока не завершит ожидание (может привести к "зависшим" процессам в <code>D</code> состоянии в <code>ps</code>).</li>
<li><strong>Стек ядра</strong>: Переполнение стека ядра приводит к панике (kernel panic), так как стек небольшой и фиксированного размера.</li>
</ol>
<hr />
<h4 id="_2"><strong>Определение</strong></h4>
<pre><code class="language-c">struct task_struct {
#ifdef CONFIG_THREAD_INFO_IN_TASK
    /*
     * For reasons of header soup (see current_thread_info()), this
     * must be the first element of task_struct.
     */
    struct thread_info      thread_info;
#endif
    unsigned int            __state;

#ifdef CONFIG_PREEMPT_RT
    /* saved state for &quot;spinlock sleepers&quot; */
    unsigned int            saved_state;
#endif

    /*
     * This begins the randomizable portion of task_struct. Only
     * scheduling-critical items should be added above here.
     */
    randomized_struct_fields_start

    void                *stack;
    refcount_t          usage;
    /* Per task flags (PF_*), defined further below: */
    unsigned int            flags;
    unsigned int            ptrace;

#ifdef CONFIG_SMP
    int             on_cpu;
    struct __call_single_node   wake_entry;
    unsigned int            wakee_flips;
    unsigned long           wakee_flip_decay_ts;
    struct task_struct      *last_wakee;

    /*
     * recent_used_cpu is initially set as the last CPU used by a task
     * that wakes affine another task. Waker/wakee relationships can
     * push tasks around a CPU where each wakeup moves to the next one.
     * Tracking a recently used CPU allows a quick search for a recently
     * used CPU that may be idle.
     */
    int             recent_used_cpu;
    int             wake_cpu;
#endif
    int             on_rq;

    int             prio;
    int             static_prio;
    int             normal_prio;
    unsigned int            rt_priority;

    struct sched_entity     se;
    struct sched_rt_entity      rt;
    struct sched_dl_entity      dl;
    const struct sched_class    *sched_class;

#ifdef CONFIG_SCHED_CORE
    struct rb_node          core_node;
    unsigned long           core_cookie;
    unsigned int            core_occupation;
#endif

#ifdef CONFIG_CGROUP_SCHED
    struct task_group       *sched_task_group;
#endif

#ifdef CONFIG_UCLAMP_TASK
    /*
     * Clamp values requested for a scheduling entity.
     * Must be updated with task_rq_lock() held.
     */
    struct uclamp_se        uclamp_req[UCLAMP_CNT];
    /*
     * Effective clamp values used for a scheduling entity.
     * Must be updated with task_rq_lock() held.
     */
    struct uclamp_se        uclamp[UCLAMP_CNT];
#endif

    struct sched_statistics         stats;

#ifdef CONFIG_PREEMPT_NOTIFIERS
    /* List of struct preempt_notifier: */
    struct hlist_head       preempt_notifiers;
#endif

#ifdef CONFIG_BLK_DEV_IO_TRACE
    unsigned int            btrace_seq;
#endif

    unsigned int            policy;
    int             nr_cpus_allowed;
    const cpumask_t         *cpus_ptr;
    cpumask_t           *user_cpus_ptr;
    cpumask_t           cpus_mask;
    void                *migration_pending;
#ifdef CONFIG_SMP
    unsigned short          migration_disabled;
#endif
    unsigned short          migration_flags;

#ifdef CONFIG_PREEMPT_RCU
    int             rcu_read_lock_nesting;
    union rcu_special       rcu_read_unlock_special;
    struct list_head        rcu_node_entry;
    struct rcu_node         *rcu_blocked_node;
#endif /* #ifdef CONFIG_PREEMPT_RCU */

#ifdef CONFIG_TASKS_RCU
    unsigned long           rcu_tasks_nvcsw;
    u8              rcu_tasks_holdout;
    u8              rcu_tasks_idx;
    int             rcu_tasks_idle_cpu;
    struct list_head        rcu_tasks_holdout_list;
#endif /* #ifdef CONFIG_TASKS_RCU */

#ifdef CONFIG_TASKS_TRACE_RCU
    int             trc_reader_nesting;
    int             trc_ipi_to_cpu;
    union rcu_special       trc_reader_special;
    struct list_head        trc_holdout_list;
    struct list_head        trc_blkd_node;
    int             trc_blkd_cpu;
#endif /* #ifdef CONFIG_TASKS_TRACE_RCU */

    struct sched_info       sched_info;

    struct list_head        tasks;
#ifdef CONFIG_SMP
    struct plist_node       pushable_tasks;
    struct rb_node          pushable_dl_tasks;
#endif

    struct mm_struct        *mm;
    struct mm_struct        *active_mm;

#ifdef SPLIT_RSS_COUNTING
    struct task_rss_stat        rss_stat;
#endif
    int             exit_state;
    int             exit_code;
    int             exit_signal;
    /* The signal sent when the parent dies: */
    int             pdeath_signal;
    /* JOBCTL_*, siglock protected: */
    unsigned long           jobctl;

    /* Used for emulating ABI behavior of previous Linux versions: */
    unsigned int            personality;

    /* Scheduler bits, serialized by scheduler locks: */
    unsigned            sched_reset_on_fork:1;
    unsigned            sched_contributes_to_load:1;
    unsigned            sched_migrated:1;
    unsigned            sched_task_hot:1;

    /* Force alignment to the next boundary: */
    unsigned            :0;

    /* Unserialized, strictly 'current' */

    /*
     * This field must not be in the scheduler word above due to wakelist
     * queueing no longer being serialized by p-&gt;on_cpu. However:
     *
     * p-&gt;XXX = X;          ttwu()
     * schedule()             if (p-&gt;on_rq &amp;&amp; ..) // false
     *   smp_mb__after_spinlock();    if (smp_load_acquire(&amp;p-&gt;on_cpu) &amp;&amp; //true
     *   deactivate_task()            ttwu_queue_wakelist())
     *     p-&gt;on_rq = 0;            p-&gt;sched_remote_wakeup = Y;
     *
     * guarantees all stores of 'current' are visible before
     * -&gt;sched_remote_wakeup gets used, so it can be in this word.
     */
    unsigned            sched_remote_wakeup:1;

    /* Bit to tell LSMs we're in execve(): */
    unsigned            in_execve:1;
    unsigned            in_iowait:1;
#ifndef TIF_RESTORE_SIGMASK
    unsigned            restore_sigmask:1;
#endif
#ifdef CONFIG_MEMCG
    unsigned            in_user_fault:1;
#endif
#ifdef CONFIG_LRU_GEN
    /* whether the LRU algorithm may apply to this access */
    unsigned            in_lru_fault:1;
#endif
#ifdef CONFIG_COMPAT_BRK
    unsigned            brk_randomized:1;
#endif
#ifdef CONFIG_CGROUPS
    /* disallow userland-initiated cgroup migration */
    unsigned            no_cgroup_migration:1;
    /* task is frozen/stopped (used by the cgroup freezer) */
    unsigned            frozen:1;
#endif
#ifdef CONFIG_BLK_CGROUP
    unsigned            use_memdelay:1;
#endif
#ifdef CONFIG_PSI
    /* Stalled due to lack of memory */
    unsigned            in_memstall:1;
#endif
#ifdef CONFIG_PAGE_OWNER
    /* Used by page_owner=on to detect recursion in page tracking. */
    unsigned            in_page_owner:1;
#endif
#ifdef CONFIG_EVENTFD
    /* Recursion prevention for eventfd_signal() */
    unsigned            in_eventfd:1;
#endif
#ifdef CONFIG_IOMMU_SVA
    unsigned            pasid_activated:1;
#endif
#ifdef  CONFIG_CPU_SUP_INTEL
    unsigned            reported_split_lock:1;
#endif
#ifdef CONFIG_TASK_DELAY_ACCT
    /* delay due to memory thrashing */
    unsigned                        in_thrashing:1;
#endif

    unsigned long           atomic_flags; /* Flags requiring atomic access. */

    struct restart_block        restart_block;

    pid_t               pid;
    pid_t               tgid;

#ifdef CONFIG_STACKPROTECTOR
    /* Canary value for the -fstack-protector GCC feature: */
    unsigned long           stack_canary;
#endif
    /*
     * Pointers to the (original) parent process, youngest child, younger sibling,
     * older sibling, respectively.  (p-&gt;father can be replaced with
     * p-&gt;real_parent-&gt;pid)
     */

    /* Real parent process: */
    struct task_struct __rcu    *real_parent;

    /* Recipient of SIGCHLD, wait4() reports: */
    struct task_struct __rcu    *parent;

    /*
     * Children/sibling form the list of natural children:
     */
    struct list_head        children;
    struct list_head        sibling;
    struct task_struct      *group_leader;

    /*
     * 'ptraced' is the list of tasks this task is using ptrace() on.
     *
     * This includes both natural children and PTRACE_ATTACH targets.
     * 'ptrace_entry' is this task's link on the p-&gt;parent-&gt;ptraced list.
     */
    struct list_head        ptraced;
    struct list_head        ptrace_entry;

    /* PID/PID hash table linkage. */
    struct pid          *thread_pid;
    struct hlist_node       pid_links[PIDTYPE_MAX];
    struct list_head        thread_group;
    struct list_head        thread_node;

    struct completion       *vfork_done;

    /* CLONE_CHILD_SETTID: */
    int __user          *set_child_tid;

    /* CLONE_CHILD_CLEARTID: */
    int __user          *clear_child_tid;

    /* PF_KTHREAD | PF_IO_WORKER */
    void                *worker_private;

    u64             utime;
    u64             stime;
#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME
    u64             utimescaled;
    u64             stimescaled;
#endif
    u64             gtime;
    struct prev_cputime     prev_cputime;
#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN
    struct vtime            vtime;
#endif

#ifdef CONFIG_NO_HZ_FULL
    atomic_t            tick_dep_mask;
#endif
    /* Context switch counts: */
    unsigned long           nvcsw;
    unsigned long           nivcsw;

    /* Monotonic time in nsecs: */
    u64             start_time;

    /* Boot based time in nsecs: */
    u64             start_boottime;

    /* MM fault and swap info: this can arguably be seen as either mm-specific or thread-specific: */
    unsigned long           min_flt;
    unsigned long           maj_flt;

    /* Empty if CONFIG_POSIX_CPUTIMERS=n */
    struct posix_cputimers      posix_cputimers;

#ifdef CONFIG_POSIX_CPU_TIMERS_TASK_WORK
    struct posix_cputimers_work posix_cputimers_work;
#endif

    /* Process credentials: */

    /* Tracer's credentials at attach: */
    const struct cred __rcu     *ptracer_cred;

    /* Objective and real subjective task credentials (COW): */
    const struct cred __rcu     *real_cred;

    /* Effective (overridable) subjective task credentials (COW): */
    const struct cred __rcu     *cred;

#ifdef CONFIG_KEYS
    /* Cached requested key. */
    struct key          *cached_requested_key;
#endif

    /*
     * executable name, excluding path.
     *
     * - normally initialized setup_new_exec()
     * - access it with [gs]et_task_comm()
     * - lock it with task_lock()
     */
    char                comm[TASK_COMM_LEN];

    struct nameidata        *nameidata;

#ifdef CONFIG_SYSVIPC
    struct sysv_sem         sysvsem;
    struct sysv_shm         sysvshm;
#endif
#ifdef CONFIG_DETECT_HUNG_TASK
    unsigned long           last_switch_count;
    unsigned long           last_switch_time;
#endif
    /* Filesystem information: */
    struct fs_struct        *fs;

    /* Open file information: */
    struct files_struct     *files;

#ifdef CONFIG_IO_URING
    struct io_uring_task        *io_uring;
#endif

    /* Namespaces: */
    struct nsproxy          *nsproxy;

    /* Signal handlers: */
    struct signal_struct        *signal;
    struct sighand_struct __rcu     *sighand;
    sigset_t            blocked;
    sigset_t            real_blocked;
    /* Restored if set_restore_sigmask() was used: */
    sigset_t            saved_sigmask;
    struct sigpending       pending;
    unsigned long           sas_ss_sp;
    size_t              sas_ss_size;
    unsigned int            sas_ss_flags;

    struct callback_head        *task_works;

#ifdef CONFIG_AUDIT
#ifdef CONFIG_AUDITSYSCALL
    struct audit_context        *audit_context;
#endif
    kuid_t              loginuid;
    unsigned int            sessionid;
#endif
    struct seccomp          seccomp;
    struct syscall_user_dispatch    syscall_dispatch;

    /* Thread group tracking: */
    u64             parent_exec_id;
    u64             self_exec_id;

    /* Protection against (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed, mempolicy: */
    spinlock_t          alloc_lock;

    /* Protection of the PI data structures: */
    raw_spinlock_t          pi_lock;

    struct wake_q_node      wake_q;

#ifdef CONFIG_RT_MUTEXES
    /* PI waiters blocked on a rt_mutex held by this task: */
    struct rb_root_cached       pi_waiters;
    /* Updated under owner's pi_lock and rq lock */
    struct task_struct      *pi_top_task;
    /* Deadlock detection and priority inheritance handling: */
    struct rt_mutex_waiter      *pi_blocked_on;
#endif

#ifdef CONFIG_DEBUG_MUTEXES
    /* Mutex deadlock detection: */
    struct mutex_waiter     *blocked_on;
#endif

#ifdef CONFIG_DEBUG_ATOMIC_SLEEP
    int             non_block_count;
#endif

#ifdef CONFIG_TRACE_IRQFLAGS
    struct irqtrace_events      irqtrace;
    unsigned int            hardirq_threaded;
    u64             hardirq_chain_key;
    int             softirqs_enabled;
    int             softirq_context;
    int             irq_config;
#endif
#ifdef CONFIG_PREEMPT_RT
    int             softirq_disable_cnt;
#endif

#ifdef CONFIG_LOCKDEP
# define MAX_LOCK_DEPTH         48UL
    u64             curr_chain_key;
    int             lockdep_depth;
    unsigned int            lockdep_recursion;
    struct held_lock        held_locks[MAX_LOCK_DEPTH];
#endif

#if defined(CONFIG_UBSAN) &amp;&amp; !defined(CONFIG_UBSAN_TRAP)
    unsigned int            in_ubsan;
#endif

    /* Journalling filesystem info: */
    void                *journal_info;

    /* Stacked block device info: */
    struct bio_list         *bio_list;

    /* Stack plugging: */
    struct blk_plug         *plug;

    /* VM state: */
    struct reclaim_state        *reclaim_state;

    struct backing_dev_info     *backing_dev_info;

    struct io_context       *io_context;

#ifdef CONFIG_COMPACTION
    struct capture_control      *capture_control;
#endif
    /* Ptrace state: */
    unsigned long           ptrace_message;
    kernel_siginfo_t        *last_siginfo;

    struct task_io_accounting   ioac;
#ifdef CONFIG_PSI
    /* Pressure stall state */
    unsigned int            psi_flags;
#endif
#ifdef CONFIG_TASK_XACCT
    /* Accumulated RSS usage: */
    u64             acct_rss_mem1;
    /* Accumulated virtual memory usage: */
    u64             acct_vm_mem1;
    /* stime + utime since last update: */
    u64             acct_timexpd;
#endif
#ifdef CONFIG_CPUSETS
    /* Protected by -&gt;alloc_lock: */
    nodemask_t          mems_allowed;
    /* Sequence number to catch updates: */
    seqcount_spinlock_t     mems_allowed_seq;
    int             cpuset_mem_spread_rotor;
    int             cpuset_slab_spread_rotor;
#endif
#ifdef CONFIG_CGROUPS
    /* Control Group info protected by css_set_lock: */
    struct css_set __rcu        *cgroups;
    /* cg_list protected by css_set_lock and tsk-&gt;alloc_lock: */
    struct list_head        cg_list;
#endif
#ifdef CONFIG_X86_CPU_RESCTRL
    u32             closid;
    u32             rmid;
#endif
#ifdef CONFIG_FUTEX
    struct robust_list_head __user  *robust_list;
#ifdef CONFIG_COMPAT
    struct compat_robust_list_head __user *compat_robust_list;
#endif
    struct list_head        pi_state_list;
    struct futex_pi_state       *pi_state_cache;
    struct mutex            futex_exit_mutex;
    unsigned int            futex_state;
#endif
#ifdef CONFIG_PERF_EVENTS
    struct perf_event_context   *perf_event_ctxp[perf_nr_task_contexts];
    struct mutex            perf_event_mutex;
    struct list_head        perf_event_list;
#endif
#ifdef CONFIG_DEBUG_PREEMPT
    unsigned long           preempt_disable_ip;
#endif
#ifdef CONFIG_NUMA
    /* Protected by alloc_lock: */
    struct mempolicy        *mempolicy;
    short               il_prev;
    short               pref_node_fork;
#endif
#ifdef CONFIG_NUMA_BALANCING
    int             numa_scan_seq;
    unsigned int            numa_scan_period;
    unsigned int            numa_scan_period_max;
    int             numa_preferred_nid;
    unsigned long           numa_migrate_retry;
    /* Migration stamp: */
    u64             node_stamp;
    u64             last_task_numa_placement;
    u64             last_sum_exec_runtime;
    struct callback_head        numa_work;

    /*
     * This pointer is only modified for current in syscall and
     * pagefault context (and for tasks being destroyed), so it can be read
     * from any of the following contexts:
     *  - RCU read-side critical section
     *  - current-&gt;numa_group from everywhere
     *  - task's runqueue locked, task not running
     */
    struct numa_group __rcu     *numa_group;

    /*
     * numa_faults is an array split into four regions:
     * faults_memory, faults_cpu, faults_memory_buffer, faults_cpu_buffer
     * in this precise order.
     *
     * faults_memory: Exponential decaying average of faults on a per-node
     * basis. Scheduling placement decisions are made based on these
     * counts. The values remain static for the duration of a PTE scan.
     * faults_cpu: Track the nodes the process was running on when a NUMA
     * hinting fault was incurred.
     * faults_memory_buffer and faults_cpu_buffer: Record faults per node
     * during the current scan window. When the scan completes, the counts
     * in faults_memory and faults_cpu decay and these values are copied.
     */
    unsigned long           *numa_faults;
    unsigned long           total_numa_faults;

    /*
     * numa_faults_locality tracks if faults recorded during the last
     * scan window were remote/local or failed to migrate. The task scan
     * period is adapted based on the locality of the faults with different
     * weights depending on whether they were shared or private faults
     */
    unsigned long           numa_faults_locality[3];

    unsigned long           numa_pages_migrated;
#endif /* CONFIG_NUMA_BALANCING */

#ifdef CONFIG_RSEQ
    struct rseq __user *rseq;
    u32 rseq_sig;
    /*
     * RmW on rseq_event_mask must be performed atomically
     * with respect to preemption.
     */
    unsigned long rseq_event_mask;
#endif

    struct tlbflush_unmap_batch tlb_ubc;

    union {
        refcount_t      rcu_users;
        struct rcu_head     rcu;
    };

    /* Cache last used pipe for splice(): */
    struct pipe_inode_info      *splice_pipe;

    struct page_frag        task_frag;

#ifdef CONFIG_TASK_DELAY_ACCT
    struct task_delay_info      *delays;
#endif

#ifdef CONFIG_FAULT_INJECTION
    int             make_it_fail;
    unsigned int            fail_nth;
#endif
    /*
     * When (nr_dirtied &gt;= nr_dirtied_pause), it's time to call
     * balance_dirty_pages() for a dirty throttling pause:
     */
    int             nr_dirtied;
    int             nr_dirtied_pause;
    /* Start of a write-and-pause period: */
    unsigned long           dirty_paused_when;

#ifdef CONFIG_LATENCYTOP
    int             latency_record_count;
    struct latency_record       latency_record[LT_SAVECOUNT];
#endif
    /*
     * Time slack values; these are used to round up poll() and
     * select() etc timeout values. These are in nanoseconds.
     */
    u64             timer_slack_ns;
    u64             default_timer_slack_ns;

#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)
    unsigned int            kasan_depth;
#endif

#ifdef CONFIG_KCSAN
    struct kcsan_ctx        kcsan_ctx;
#ifdef CONFIG_TRACE_IRQFLAGS
    struct irqtrace_events      kcsan_save_irqtrace;
#endif
#ifdef CONFIG_KCSAN_WEAK_MEMORY
    int             kcsan_stack_depth;
#endif
#endif

#ifdef CONFIG_KMSAN
    struct kmsan_ctx        kmsan_ctx;
#endif

#if IS_ENABLED(CONFIG_KUNIT)
    struct kunit            *kunit_test;
#endif

#ifdef CONFIG_FUNCTION_GRAPH_TRACER
    /* Index of current stored address in ret_stack: */
    int             curr_ret_stack;
    int             curr_ret_depth;

    /* Stack of return addresses for return function tracing: */
    struct ftrace_ret_stack     *ret_stack;

    /* Timestamp for last schedule: */
    unsigned long long      ftrace_timestamp;

    /*
     * Number of functions that haven't been traced
     * because of depth overrun:
     */
    atomic_t            trace_overrun;

    /* Pause tracing: */
    atomic_t            tracing_graph_pause;
#endif

#ifdef CONFIG_TRACING
    /* Bitmask and counter of trace recursion: */
    unsigned long           trace_recursion;
#endif /* CONFIG_TRACING */

#ifdef CONFIG_KCOV
    /* See kernel/kcov.c for more details. */

    /* Coverage collection mode enabled for this task (0 if disabled): */
    unsigned int            kcov_mode;

    /* Size of the kcov_area: */
    unsigned int            kcov_size;

    /* Buffer for coverage collection: */
    void                *kcov_area;

    /* KCOV descriptor wired with this task or NULL: */
    struct kcov         *kcov;

    /* KCOV common handle for remote coverage collection: */
    u64             kcov_handle;

    /* KCOV sequence number: */
    int             kcov_sequence;

    /* Collect coverage from softirq context: */
    unsigned int            kcov_softirq;
#endif

#ifdef CONFIG_MEMCG
    struct mem_cgroup       *memcg_in_oom;
    gfp_t               memcg_oom_gfp_mask;
    int             memcg_oom_order;

    /* Number of pages to reclaim on returning to userland: */
    unsigned int            memcg_nr_pages_over_high;

    /* Used by memcontrol for targeted memcg charge: */
    struct mem_cgroup       *active_memcg;
#endif

#ifdef CONFIG_BLK_CGROUP
    struct request_queue        *throttle_queue;
#endif

#ifdef CONFIG_UPROBES
    struct uprobe_task      *utask;
#endif
#if defined(CONFIG_BCACHE) || defined(CONFIG_BCACHE_MODULE)
    unsigned int            sequential_io;
    unsigned int            sequential_io_avg;
#endif
    struct kmap_ctrl        kmap_ctrl;
#ifdef CONFIG_DEBUG_ATOMIC_SLEEP
    unsigned long           task_state_change;
# ifdef CONFIG_PREEMPT_RT
    unsigned long           saved_state_change;
# endif
#endif
    int             pagefault_disabled;
#ifdef CONFIG_MMU
    struct task_struct      *oom_reaper_list;
    struct timer_list       oom_reaper_timer;
#endif
#ifdef CONFIG_VMAP_STACK
    struct vm_struct        *stack_vm_area;
#endif
#ifdef CONFIG_THREAD_INFO_IN_TASK
    /* A live task holds one reference: */
    refcount_t          stack_refcount;
#endif
#ifdef CONFIG_LIVEPATCH
    int patch_state;
#endif
#ifdef CONFIG_SECURITY
    /* Used by LSM modules for access restriction: */
    void                *security;
#endif
#ifdef CONFIG_BPF_SYSCALL
    /* Used by BPF task local storage */
    struct bpf_local_storage __rcu  *bpf_storage;
    /* Used for BPF run context */
    struct bpf_run_ctx      *bpf_ctx;
#endif

#ifdef CONFIG_GCC_PLUGIN_STACKLEAK
    unsigned long           lowest_stack;
    unsigned long           prev_lowest_stack;
#endif

#ifdef CONFIG_X86_MCE
    void __user         *mce_vaddr;
    __u64               mce_kflags;
    u64             mce_addr;
    __u64               mce_ripv : 1,
                    mce_whole_page : 1,
                    __mce_reserved : 62;
    struct callback_head        mce_kill_me;
    int             mce_count;
#endif

#ifdef CONFIG_KRETPROBES
    struct llist_head               kretprobe_instances;
#endif
#ifdef CONFIG_RETHOOK
    struct llist_head               rethooks;
#endif

#ifdef CONFIG_ARCH_HAS_PARANOID_L1D_FLUSH
    /*
     * If L1D flush is supported on mm context switch
     * then we use this callback head to queue kill work
     * to kill tasks that are not running on SMT disabled
     * cores
     */
    struct callback_head        l1d_flush_kill;
#endif

#ifdef CONFIG_RV
    /*
     * Per-task RV monitor. Nowadays fixed in RV_PER_TASK_MONITORS.
     * If we find justification for more monitors, we can think
     * about adding more or developing a dynamic method. So far,
     * none of these are justified.
     */
    union rv_task_monitor       rv[RV_PER_TASK_MONITORS];
#endif

    /*
     * New fields for task_struct should be added above here, so that
     * they are included in the randomized portion of task_struct.
     */
    randomized_struct_fields_end

    /* CPU-specific state of this task: */
    struct thread_struct        thread;

    /*
     * WARNING: on x86, 'thread_struct' contains a variable-sized
     * structure.  It *MUST* be at the end of 'task_struct'.
     *
     * Do not put anything below here!
     */
};

static inline struct pid *task_pid(struct task_struct *task)
{
    return task-&gt;thread_pid;
}

/*
 * the helpers to get the task's different pids as they are seen
 * from various namespaces
 *
 * task_xid_nr()     : global id, i.e. the id seen from the init namespace;
 * task_xid_vnr()    : virtual id, i.e. the id seen from the pid namespace of
 *                     current.
 * task_xid_nr_ns()  : id seen from the ns specified;
 *
 * see also pid_nr() etc in include/linux/pid.h
 */
pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type, struct pid_namespace *ns);

static inline pid_t task_pid_nr(struct task_struct *tsk)
{
    return tsk-&gt;pid;
}

static inline pid_t task_pid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_PID, ns);
}

static inline pid_t task_pid_vnr(struct task_struct *tsk)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_PID, NULL);
}


static inline pid_t task_tgid_nr(struct task_struct *tsk)
{
    return tsk-&gt;tgid;
}

/**
 * pid_alive - check that a task structure is not stale
 * @p: Task structure to be checked.
 *
 * Test if a process is not yet dead (at most zombie state)
 * If pid_alive fails, then pointers within the task structure
 * can be stale and must not be dereferenced.
 *
 * Return: 1 if the process is alive. 0 otherwise.
 */
static inline int pid_alive(const struct task_struct *p)
{
    return p-&gt;thread_pid != NULL;
}

static inline pid_t task_pgrp_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_PGID, ns);
}

static inline pid_t task_pgrp_vnr(struct task_struct *tsk)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_PGID, NULL);
}


static inline pid_t task_session_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_SID, ns);
}

static inline pid_t task_session_vnr(struct task_struct *tsk)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_SID, NULL);
}

static inline pid_t task_tgid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_TGID, ns);
}

static inline pid_t task_tgid_vnr(struct task_struct *tsk)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_TGID, NULL);
}

static inline pid_t task_ppid_nr_ns(const struct task_struct *tsk, struct pid_namespace *ns)
{
    pid_t pid = 0;

    rcu_read_lock();
    if (pid_alive(tsk))
        pid = task_tgid_nr_ns(rcu_dereference(tsk-&gt;real_parent), ns);
    rcu_read_unlock();

    return pid;
}

static inline pid_t task_ppid_nr(const struct task_struct *tsk)
{
    return task_ppid_nr_ns(tsk, &amp;init_pid_ns);
}

/* Obsolete, do not use: */
static inline pid_t task_pgrp_nr(struct task_struct *tsk)
{
    return task_pgrp_nr_ns(tsk, &amp;init_pid_ns);
}

</code></pre>
<hr />
<h4 id="_3"><strong>Пример</strong></h4>
<p>Модуль выводит информацию о текущем процессе, его родителе и всех запущенных процессах в системе.</p>
<pre><code class="language-c">
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/sched/signal.h&gt; // Для доступа к for_each_process()
#include &lt;linux/sched.h&gt;        // Для task_struct

MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;OldALoneFag&quot;);
MODULE_DESCRIPTION(&quot;Task_struct demo module&quot;);

// Вывод информации о процессе
static void print_task_info(struct task_struct *task) {
    char state_str[32];

    // Преобразуем состояние процесса в строку
    switch (task-&gt;__state) {
        case TASK_RUNNING:          strcpy(state_str, &quot;RUNNING&quot;); break;
        case TASK_INTERRUPTIBLE:    strcpy(state_str, &quot;INTERRUPTIBLE&quot;); break;
        case TASK_UNINTERRUPTIBLE:  strcpy(state_str, &quot;UNINTERRUPTIBLE&quot;); break;
        case __TASK_STOPPED:        strcpy(state_str, &quot;STOPPED&quot;); break;
        default:                    snprintf(state_str, 32, &quot;UNKNOWN (%ld)&quot;, task-&gt;__state);
    }

    printk(KERN_INFO
        &quot;PID: %d | PPID: %d | Name: %-16s | State: %-16s | TGID: %d | CPU: %d\n&quot;,
        task-&gt;pid,
        task-&gt;parent-&gt;pid,
        task-&gt;comm,
        state_str,
        task-&gt;tgid,
        task-&gt;cpu
    );
}

// Вывод информации о текущем процессе
static void print_current_task_info(void) {
    struct task_struct *current_task = current;

    printk(KERN_INFO &quot;\n=== Current Task ===\n&quot;);
    print_task_info(current_task);
    printk(KERN_INFO &quot;Start time: %llu ns\n&quot;, current_task-&gt;start_time);
}

// Обход всех процессов в системе
static void list_all_processes(void) {
    struct task_struct *task;

    printk(KERN_INFO &quot;\n=== All Processes ===\n&quot;);

    rcu_read_lock(); // Блокировка RCU для безопасного обхода
    for_each_process(task) {
        print_task_info(task);
    }
    rcu_read_unlock();
}

static int __init task_info_init(void) {
    printk(KERN_INFO &quot;Task Info Module: Loaded\n&quot;);

    // Информация о текущем процессе (insmod/modprobe)
    print_current_task_info();

    // Список всех процессов
    list_all_processes();

    return 0;
}

static void __exit task_info_exit(void) {
    printk(KERN_INFO &quot;Task Info Module: Unloaded\n&quot;);
}

module_init(task_info_init);
module_exit(task_info_exit);

</code></pre>
<h4 id="_4"><strong>Пояснения к примеру:</strong></h4>
<ol>
<li><strong><code>print_task_info</code></strong>:</li>
<li>
<p>Выводит ключевые поля <code>task_struct</code>:</p>
<ul>
<li><code>pid</code> — идентификатор процесса</li>
<li><code>parent-&gt;pid</code> — PID родителя</li>
<li><code>comm</code> — имя исполняемого файла (до 16 символов)</li>
<li><code>__state</code> — состояние процесса</li>
<li><code>tgid</code> — идентификатор группы потоков</li>
<li><code>cpu</code> — номер CPU, на котором выполняется процесс</li>
</ul>
</li>
<li>
<p><strong><code>print_current_task_info</code></strong>:</p>
</li>
<li>Использует <code>current</code> для получения текущего процесса (которым будет <code>insmod</code> или <code>modprobe</code> при загрузке модуля).</li>
<li>
<p>Добавляет вывод времени старта (<code>start_time</code>).</p>
</li>
<li>
<p><strong><code>list_all_processes</code></strong>:</p>
</li>
<li>Использует <code>for_each_process()</code> для итерации по всем процессам в системе.</li>
<li><code>rcu_read_lock()</code> гарантирует безопасность при обходе.</li>
</ol>
<hr />
<p>Структура <code>task_struct</code> — это сердце управления процессами в Linux. Её сложность отражает многообразие функций, которые ядро выполняет для обеспечения работы системы.</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
