<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Process - OTUS-linux-kernel-dev</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Process";
        var mkdocs_page_input_path = "task_struct.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> OTUS-linux-kernel-dev
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Process</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#linux_1">Процесс в операционной системе Linux</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_1">Компоненты процесса</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1-machine">1. Машина или хардверная часть (Machine)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2-memory">2. Память (Memory)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#3-io-resources">3. Ввод-вывод (I/O Resources)</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#examplec">Разбор программы example.c</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_2">Разбор адресного пространства</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#readelf">Анализ вывода readelf</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_3">Общая информация о файле</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_4">Структура сегментов</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cat-procpidmaps">Вывод cat /proc/pid/maps</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_5">Структура вывода</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_6">Разрешения памяти</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_7">Основные секции памяти</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">Разбор ассемблерного кода</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_9">Глобальные переменные**</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#main">Функция main</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_10">Структура стека</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#pid">Получение PID и сохранение значений</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_11">Динамическое выделение памяти</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#pid_1">Инициализация выделенной памяти и вывод PID</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_12">Бесконечный цикл</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_13">Вывод</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#task_struct">task_struct</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#task_struct_1">Основные компоненты task_struct</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1">1. Идентификаторы процесса</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2">2. Состояние процесса</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#3">3. Связи между процессами</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#4">4. Планирование и время</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#5">5. Управление памятью</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#6">6. Файлы и файловая система</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#7">7. Сигналы</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#8">8. Учётные данные и права доступа</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#9">9. Потоки выполнения</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#10-namespaces">10. Пространства имён (Namespaces)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#11-cgroups">11. Контрольные группы (cgroups)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12">12. Сетевые параметры</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#13">13. Отладка и трассировка</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#14">14. Ресурсы и ограничения</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#15">15. Прочее</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_14">Важные замечания</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_15">Определение</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_16">Пример</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_17">Пояснения к примеру:</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#linux_2">Процесс создания процесса в Linux</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#fork">Реализация системного вызова fork</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#clone">Реализация clone</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#copy_process">Реализация copy_process</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_18">Детальный разбор функциональности</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_19">Процесс активации процесса</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_20">Детальный разбор действий</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">OTUS-linux-kernel-dev</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Process</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="linux">Процессы и потоки в ядре Linux</h1>
<h2 id="linux_1">Процесс в операционной системе Linux</h2>
<p>Процесс представляет собой фундаментальную абстракцию операционной системы, которая объединяет несколько ключевых ресурсов для обеспечения изолированного выполнения программы. Давайте рассмотрим структуру процесса и его компоненты:</p>
<p>На диаграмме представлена иерархическая структура процесса, где:</p>
<p><center>
<img alt="Диаграмма 2" src="../process1.png" title="диаграмма 1" />
</center></p>
<p>Стрелки показывают зависимость между уровнями: машинное состояние управляет распределением памяти, которая в свою очередь влияет на доступ к ресурсам ввода-вывода.</p>
<h3 id="_1">Компоненты процесса</h3>
<h4 id="1-machine">1. Машина или хардверная часть (Machine)</h4>
<p><strong>Регистры процессора, включая специальные регистры:</strong></p>
<ul>
<li>Программный счетчик (PC/IP) - указывает на следующую инструкцию для выполнения</li>
<li>Указатель стека и связанные с ним регистры для управления функциями</li>
<li>Общие регистры для временного хранения данных </li>
</ul>
<h4 id="2-memory">2. Память (Memory)</h4>
<p><strong>Адресное пространство процесса, включающее:</strong></p>
<ul>
<li>Код программы - исполняемые инструкции</li>
<li>Статические данные - инициализированные переменные</li>
<li>Куча (heap) - динамически выделяемая память для структур данных</li>
<li>Стек - область для локальных переменных и параметров функций </li>
</ul>
<h4 id="3-io-resources">3. Ввод-вывод (I/O Resources)</h4>
<ul>
<li>Открытые файловые дескрипторы</li>
<li>Настройки окружения процесса</li>
<li>Системные ресурсы ввода-вывода </li>
</ul>
<h2 id="examplec">Разбор программы example.c</h2>
<p>Посмотрим на компоненты нашего собственного процесса в приближении us.</p>
<p>Листинг кода нашей программы example</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int global_var = 42;

static int uninit_var;

int main(void) {
    int stack_var;
    int *heap_var;
    pid_t pid;

    pid = getpid(); 
    stack_var = 100;

    heap_var = malloc(sizeof(int));
    *heap_var = 200;

    printf(&quot;pid = %d\n&quot;, pid);

    while(1) {}

    return 0;
}

</code></pre>
<h3 id="_2">Разбор адресного пространства</h3>
<p>Давайте разберем структуру ELF-файла и его организацию в памяти. Это важно для понимания того, как работает ваша программа при выполнении.</p>
<p>Воспользуемся утилитой <code>readelf</code>.</p>
<pre><code class="language-sh">readelf -l example
</code></pre>
<p>Вывод команды представлен ниже:</p>
<pre><code class="language-sh">Тип файла ELF — DYN (Position-Independent Executable file)
Entry point 0x1070
There are 13 program headers, starting at offset 64

Заголовки программы:
  Тип            Смещ.              Вирт.адр           Физ.адр
                 Рзм.фйл            Рзм.пм              Флаги  Выравн
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Запрашиваемый интерпретатор программы: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000688 0x0000000000000688  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x00000000000001ad 0x00000000000001ad  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x00000000000000e8 0x00000000000000e8  R      0x1000
  LOAD           0x0000000000002dd0 0x0000000000003dd0 0x0000000000003dd0
                 0x000000000000025c 0x0000000000000268  RW     0x1000
  DYNAMIC        0x0000000000002de0 0x0000000000003de0 0x0000000000003de0
                 0x00000000000001e0 0x00000000000001e0  RW     0x8
  NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000020 0x0000000000000020  R      0x8
  NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000020 0x0000000000000020  R      0x8
  GNU_EH_FRAME   0x0000000000002010 0x0000000000002010 0x0000000000002010
                 0x000000000000002c 0x000000000000002c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000002dd0 0x0000000000003dd0 0x0000000000003dd0
                 0x0000000000000230 0x0000000000000230  R      0x1

 Соответствие раздел-сегмент:
  Сегмент Разделы...
   00     
   01     .interp 
   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 
   03     .init .plt .plt.got .text .fini 
   04     .rodata .eh_frame_hdr .eh_frame 
   05     .init_array .fini_array .dynamic .got .got.plt .data .bss 
   06     .dynamic 
   07     .note.gnu.property 
   08     .note.gnu.build-id .note.ABI-tag 
   09     .note.gnu.property 
   10     .eh_frame_hdr 
   11     
   12     .init_array .fini_array .dynamic .got 

</code></pre>
<h4 id="readelf">Анализ вывода readelf</h4>
<h4 id="_3">Общая информация о файле</h4>
<ul>
<li>Тип файла: DYN (динамически связанный исполняемый файл)</li>
<li>Точка входа: <code>0x1070</code></li>
<li>Количество заголовков программы: 13</li>
<li>Смещение начала заголовков: 64 байта</li>
</ul>
<h4 id="_4">Структура сегментов</h4>
<p><strong>PHDR (Заголовок программы)</strong></p>
<ul>
<li>Расположен по адресу: <code>0x40</code></li>
<li>Размер: <code>0x2d8</code> байт</li>
<li>Флаги: R (только чтение)</li>
</ul>
<p><strong>INTERP (Интерпретатор)</strong></p>
<ul>
<li>Адрес: <code>0x318</code></li>
<li>Размер: <code>0x1c</code> байт</li>
<li>Указывает на динамический загрузчик: <code>/lib64/ld-linux-x86-64.so.2</code></li>
</ul>
<p><strong>LOAD сегменты (загружаемые секции)</strong></p>
<p>Четыре основных LOAD сегмента с разными правами доступа:</p>
<ol>
<li>Только чтение (R)</li>
<li>Чтение и выполнение (R E)</li>
<li>Чтение и запись (RW)</li>
</ol>
<p><strong>DYNAMIC</strong></p>
<ul>
<li>Содержит информацию для динамического связывания</li>
<li>Размер: <code>0x1e0</code> байт</li>
<li>Права доступа: чтение и запись (RW)</li>
</ul>
<p><strong>Специальные сегменты</strong></p>
<p>Файл содержит несколько специальных сегментов для обработки исключений и безопасности:</p>
<ul>
<li><code>GNU_EH_FRAME</code>: структуры обработки исключений</li>
<li><code>GNU_STACK</code>: настройки стека</li>
<li><code>GNU_RELRO</code>: область только для чтения после связывания</li>
<li><code>NOTE</code>: секции с дополнительной информацией</li>
</ul>
<p><strong>Соответствие сегментов и секций</strong></p>
<p>Каждый сегмент содержит определенные секции ELF:</p>
<ul>
<li>Секция <code>.interp</code> и связанные с ней метаданные</li>
<li>Динамические секции (<code>.dynsym</code>, <code>.dynstr</code> и т.д.)</li>
<li>Исходный код (<code>.init</code>, <code>.text</code>)</li>
<li>Данные (<code>.data</code>, <code>.bss</code>)</li>
<li>Информация о динамическом связывании (<code>.dynamic</code>)</li>
</ul>
<p>У каждой исполняющейся программы свое адресное пространство, адреса которые показаны в readelf в действительности другие, ядро выделяет память под каждый сегмент самостоятельно.</p>
<h3 id="cat-procpidmaps">Вывод <code>cat /proc/pid/maps</code></h3>
<p>Давайте проанализируем вывод файла <code>/proc/16446/maps</code>, который показывает карту памяти процесса с <code>pid</code> 16446.</p>
<h4 id="_5">Структура вывода</h4>
<ul>
<li>Адресный диапазон (начало-конец) в виртуальном адресном пространстве</li>
<li>Разрешения доступа (r/w/x/p/s)</li>
<li>Смещение в файле</li>
<li>Номера устройства (major:minor)</li>
<li>Номер inode</li>
<li>Путь к файлу или специальное обозначение</li>
</ul>
<h4 id="_6">Разрешения памяти</h4>
<ul>
<li><code>r</code> - чтение</li>
<li><code>w</code> - запись</li>
<li><code>x</code> - выполнение</li>
<li><code>p</code> - приватная область памяти</li>
<li><code>s</code> - разделяемая область памяти</li>
</ul>
<h4 id="_7">Основные секции памяти</h4>
<pre><code>5610ee5d9000-5610ee5da000 r--p 00000000 fe:02 2390217 /home/gleb/example
5610ee5da000-5610ee5db000 r-xp 00001000 fe:02 2390217 /home/gleb/example
5610ee5db000-5610ee5dc000 r--p 00002000 fe:02 2390217 /home/gleb/example
5610ee5dc000-5610ee5dd000 r--p 00002000 fe:02 2390217 /home/gleb/example
5610ee5dd000-5610ee5de000 rw-p 00003000 fe:02 2390217 /home/gleb/example
</code></pre>
<p>Разделены на секции с разными разрешениями:</p>
<ul>
<li>Первая секция только для чтения (содержит заголовок файла)</li>
<li>Вторая секция для чтения и выполнения (код программы)</li>
<li>Последняя секция для чтения и записи (данные программы)</li>
</ul>
<p><strong>Куча программы:</strong></p>
<pre><code>5610f5260000-5610f5281000 rw-p 00000000 00:00 0 [heap]
</code></pre>
<ul>
<li>Динамически выделяемая память</li>
<li>Разрешены чтение и запись</li>
<li>Используется для malloc/free</li>
</ul>
<p><strong>Библиотека libc:</strong></p>
<pre><code>7f05f5423000-7f05f5449000 r--p 00000000 fe:00 1571102 /usr/lib/x86_64-linux-gnu/libc.so.6
7f05f5449000-7f05f559e000 r-xp 00026000 fe:00 1571102 /usr/lib/x86_64-linux-gnu/libc.so.6
7f05f559e000-7f05f55f1000 r--p 0017b000 fe:00 1571102 /usr/lib/x86_64-linux-gnu/libc.so.6
</code></pre>
<p>Стандартная библиотека C разделена на секции с разными правами доступа</p>
<p><strong>Стек процесса:</strong></p>
<pre><code>7ffefede9000-7ffefee0a000 rw-p 00000000 00:00 0 [stack]
</code></pre>
<ul>
<li>Расположен в верхней части адресного пространства</li>
<li>Используется для локальных переменных и вызовов функций</li>
<li>Размер определяется системой</li>
</ul>
<p><strong>Специальные секции:</strong></p>
<pre><code>7ffefee21000-7ffefee23000 r-xp 00000000 00:00 0 [vdso]
7ffefee1d000-7ffefee21000 r--p 00000000 00:00 0 [vvar]
</code></pre>
<ul>
<li>vdso - виртуальный динамический общий объект</li>
<li>vvar - виртуальное адресное пространство переменных ядра</li>
<li>Необходимы для эффективного взаимодействия с ядром</li>
</ul>
<h3 id="_8">Разбор ассемблерного кода</h3>
<p>Получить ассемблерный код из <code>example.c</code> файла можно несколькими способами или использовать <a href="https://godbolt.org/z/EfPMoGPd9">godbolt.org</a></p>
<pre><code class="language-sh">gcc -S -O0 example.c -o example
</code></pre>
<p>Давайте разберем этот ассемблерный код построчно. Код написан на x86-64 в синтаксисе AT&amp;T и представляет собой простую программу, которая получает идентификатор процесса и выводит его на экран.</p>
<h4 id="_9">Глобальные переменные**</h4>
<pre><code class="language-nasm">global_var:
.long 42
.LC0:
.string &quot;pid = %d\n&quot;
</code></pre>
<ul>
<li><code>global_var</code> - метка для глобальной переменной</li>
<li><code>.long 42</code> - определяет 32-битную целую константу со значением 42 в памяти</li>
<li><code>.LC0</code> - локальная метка для строковой константы</li>
<li><code>.string "pid = %d\n"</code> - определяет строку форматирования для printf с форматным спецификатором %d и символом новой строки</li>
</ul>
<h4 id="main">Функция main</h4>
<pre><code class="language-nasm">main:
push rbp          # Сохраняем базовый указатель кадра стека
mov rbp, rsp      # Устанавливаем новый базовый указатель кадра
sub rsp, 16       # Выделяем 16 байт на стеке для локальных переменных
</code></pre>
<p>Эти инструкции устанавливают кадр стека функции main:</p>
<ul>
<li>Сохраняют предыдущее значение rbp на стеке</li>
<li>Устанавливают новый базовый указатель кадра</li>
<li>Выделяют место для локальных переменных</li>
</ul>
<h4 id="_10">Структура стека</h4>
<p><center>
<img alt="Диаграмма 2" src="../stack.png" title="диаграмма 2" />
</center></p>
<p>На диаграмме показана структура стека после выполнения трёх начальных инструкций:</p>
<ul>
<li>Розовым выделено сохранённое значение старого RBP</li>
<li>Голубым показан новый RBP, который указывает на начало текущего кадра функции</li>
<li>Жёлтым обозначена область для локальных переменных размером 16 байт</li>
<li>Стрелки показывают, что стек растёт вниз по адресам памяти</li>
</ul>
<h4 id="pid">Получение PID и сохранение значений</h4>
<pre><code class="language-nasm">call getpid          # Вызов системного вызова для получения PID процесса
mov DWORD PTR [rbp-4], eax  # Сохраняем полученный PID в локальной переменной
mov DWORD PTR [rbp-8], 100  # Инициализируем другую локальную переменную значением 100
</code></pre>
<p>Эти инструкции:</p>
<ul>
<li>Вызывают системный вызов getpid() через call</li>
<li>Сохраняют результат (PID) в памяти относительно rbp-4</li>
<li>Инициализируют вторую локальную переменную значением 100</li>
</ul>
<h4 id="_11">Динамическое выделение памяти</h4>
<pre><code class="language-nasm">mov edi, 4           # Размер блока памяти для выделения (4 байта)
call malloc          # Вызов функции malloc
mov QWORD PTR [rbp-16], rax  # Сохраняем указатель на выделенную память
</code></pre>
<p>Этот блок кода выделяет динамическую память:</p>
<ul>
<li>edi содержит размер запрошенной памяти (4 байта)</li>
<li>malloc выделяет память и возвращает указатель в rax</li>
<li>Указатель сохраняется в локальной переменной [rbp-16]</li>
</ul>
<h4 id="pid_1">Инициализация выделенной памяти и вывод PID</h4>
<pre><code class="language-nasm">mov rax, QWORD PTR [rbp-16]  # Загружаем указатель на выделенную память
mov DWORD PTR [rax], 200     # Записываем значение 200 в выделенную память
mov eax, DWORD PTR [rbp-4]   # Загружаем PID в eax
mov esi, eax                # Перемещаем PID в esi (второй аргумент printf)
mov edi, OFFSET FLAT:.LC0   # Загружаем адрес строки формата в edi
mov eax, 0                  # Обнуляем eax (требуется для системных вызовов)
call printf                 # Вызываем printf для вывода PID
</code></pre>
<p>Этот блок выполняет:</p>
<ul>
<li>Инициализацию выделенной памяти значением 200</li>
<li>Подготовку аргументов для printf:</li>
<li>Строка формата через edi</li>
<li>Значение PID через esi</li>
<li>Вызов printf для вывода результата</li>
</ul>
<h4 id="_12">Бесконечный цикл</h4>
<pre><code class="language-nasm">.L2:
jmp .L2              # Переход к метке .L2 (бесконечный цикл)
</code></pre>
<p>Последний блок создаёт бесконечный цикл:</p>
<ul>
<li>Метка .L2 отмечает начало цикла</li>
<li>jmp .L2 создает переход к этой метке, заставляя программу выполняться бесконечно</li>
</ul>
<p>Таким образом, программа выполняет все необходимые действия последовательно, а затем заходит в бесконечный цикл, где и завершает своё выполнение.</p>
<h3 id="_13">Вывод</h3>
<p>Процесс представляет собой фундаментальную концепцию в архитектуре операционных систем, являясь основным объектом управления при выполнении программ. Анализ ассемблерного кода и структуры процесса позволяет глубже понять его значение в работе системы. Как показывает изучение ассемблерного кода, программа реализуется через набор машинных инструкций, которые осуществляют прямое взаимодействие с регистрами процессора, что обеспечивает базовый уровень выполнения программы. При этом программа организована в логические секции, которые затем группируются в сегменты памяти, загружаемые ядром операционной системы для эффективного управления ресурсами процесса.</p>
<h2 id="task_struct">task_struct</h2>
<p>Структура <code>task_struct</code> в ядре Linux — это фундаментальная структура данных, описывающая процесс или поток (нить). Она содержит всю информацию, необходимую ядру для управления задачами: состояние выполнения, идентификаторы, ресурсы, планирование и многое другое. Ниже приведено подробное описание её ключевых полей и их назначения.</p>
<hr />
<h3 id="task_struct_1"><strong>Основные компоненты <code>task_struct</code></strong></h3>
<p>Структура определена в файле <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h"><code>include/linux/sched.h</code></a> и постоянно развивается. Рассмотрим основные группы полей.</p>
<hr />
<h4 id="1"><strong>1. Идентификаторы процесса</strong></h4>
<p>Поля, связанные с идентификаторами, позволяют ядру однозначно определять процессы и управлять их группами:</p>
<h5 id="pid_t-pid"><strong><code>pid_t pid</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Уникальный идентификатор процесса (Process ID).</li>
<li><strong>Особенности</strong>:</li>
<li>При создании процесса через <code>fork()</code> или <code>clone()</code> ядро выделяет новый <code>pid</code>.</li>
<li>Для потоков (нитей) в многопоточном приложении каждый поток имеет свой уникальный <code>pid</code>, но общий <code>tgid</code> (см. ниже).</li>
<li>PID 1 обычно присваивается процессу <code>init</code> (или <code>systemd</code> в современных системах).</li>
</ul>
<h5 id="pid_t-tgid-thread-group-id"><strong><code>pid_t tgid</code></strong> (Thread Group ID)</h5>
<ul>
<li><strong>Назначение</strong>: Идентификатор группы потоков. </li>
<li><strong>Особенности</strong>:</li>
<li>Для <strong>однопоточного</strong> процесса <code>pid == tgid</code>.</li>
<li>Для <strong>многопоточного</strong> приложения все потоки имеют одинаковый <code>tgid</code>, равный <code>pid</code> основного потока (того, который был создан первым).</li>
<li>Системные вызовы <code>getpid()</code> возвращают именно <code>tgid</code>, чтобы пользовательское пространство видело группу потоков как единый процесс.</li>
</ul>
<h5 id="struct-task_struct-group_leader"><strong><code>struct task_struct *group_leader</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Указатель на "лидера" группы потоков.</li>
<li><strong>Особенности</strong>:</li>
<li>Для многопоточного приложения <code>group_leader</code> указывает на <code>task_struct</code> основного потока.</li>
<li>При завершении лидера все потоки группы получают сигнал <code>SIGHUP</code> (если не настроено иное).</li>
</ul>
<hr />
<h4 id="2"><strong>2. Состояние процесса</strong></h4>
<h5 id="volatile-long-state"><strong><code>volatile long state</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Текущее состояние задачи. Определяет, может ли процесс быть выбран планировщиком для выполнения.</li>
<li><strong>Возможные значения</strong>:</li>
<li><strong><code>TASK_RUNNING</code></strong>:<ul>
<li>Процесс готов к выполнению (стоит в очереди планировщика) или уже выполняется.</li>
</ul>
</li>
<li><strong><code>TASK_INTERRUPTIBLE</code></strong>:<ul>
<li>Процесс ожидает события (например, данных из сокета или завершения системного вызова).</li>
<li><strong>Может быть прерван сигналом</strong> (например, <code>SIGKILL</code>). После получения сигнала процесс переходит в <code>TASK_RUNNING</code> и обрабатывает его.</li>
</ul>
</li>
<li><strong><code>TASK_UNINTERRUPTIBLE</code></strong>:<ul>
<li>Процесс ожидает события, но <strong>не реагирует на сигналы</strong> (используется для критических операций, таких как доступ к диску).</li>
<li>Пример: чтение данных с повреждённого диска, где прерывание может привести к неконсистентности.</li>
</ul>
</li>
<li><strong><code>__TASK_STOPPED</code></strong>:<ul>
<li>Процесс остановлен внешним сигналом (например, <code>SIGSTOP</code> или отладчиком). Возобновляется сигналом <code>SIGCONT</code>.</li>
</ul>
</li>
<li><strong><code>EXIT_ZOMBIE</code></strong>:<ul>
<li>Процесс завершился, но его родитель ещё не вызвал <code>wait()</code>, чтобы получить код завершения. В этом состоянии процесс уже не использует ресурсы, кроме <code>task_struct</code>.</li>
</ul>
</li>
<li><strong><code>EXIT_DEAD</code></strong>:<ul>
<li>Финальное состояние перед удалением <code>task_struct</code> из системы (после вызова <code>wait()</code> родителем).</li>
</ul>
</li>
</ul>
<h5 id="int-exit_state"><strong><code>int exit_state</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Дополнительные флаги завершения процесса.</li>
<li><strong>Примеры значений</strong>:</li>
<li><code>EXIT_ZOMBIE</code>: Процесс завершился, но родитель ещё не обработал его.</li>
<li><code>EXIT_DEAD</code>: Процесс полностью удалён из системы.</li>
</ul>
<hr />
<h4 id="3"><strong>3. Связи между процессами</strong></h4>
<ul>
<li><strong><code>struct task_struct *parent</code></strong>: Указатель на родительский процесс.</li>
<li><strong><code>struct list_head children</code></strong>: Список дочерних процессов.</li>
<li><strong><code>struct list_head sibling</code></strong>: Список "братьев" (процессы с тем же родителем).</li>
<li><strong><code>struct list_head tasks</code></strong>: Элемент глобального списка всех задач.</li>
</ul>
<hr />
<h4 id="4"><strong>4. Планирование и время</strong></h4>
<ul>
<li><strong><code>int prio</code></strong>: Динамический приоритет (учитывает "nice" и поведение).</li>
<li><strong><code>int static_prio</code></strong>: Статический приоритет (значение <code>nice</code> от -20 до 19).</li>
<li><strong><code>const struct sched_class *sched_class</code></strong>: Класс планировщика (например, <code>SCHED_NORMAL</code>, <code>SCHED_FIFO</code>).</li>
<li><strong><code>struct sched_entity se</code></strong>: Данные для планировщика CFS (Completely Fair Scheduler).</li>
<li><strong><code>u64 utime</code></strong>, <strong><code>u64 stime</code></strong>: Время выполнения в пользовательском и системном режиме.</li>
<li><strong><code>unsigned long start_time</code></strong>: Время создания процесса.</li>
</ul>
<hr />
<h4 id="5"><strong>5. Управление памятью</strong></h4>
<h5 id="struct-mm_struct-mm"><strong><code>struct mm_struct *mm</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Указатель на структуру, описывающую виртуальную память процесса.</li>
<li><strong>Содержимое <code>mm_struct</code></strong>:</li>
<li>Таблица страниц (Page Table) — преобразует виртуальные адреса в физические.</li>
<li>Список областей памяти (VMA — Virtual Memory Areas): сегменты кода, данных, стека, кучи, разделяемых библиотек.</li>
<li>Информация о сегментах (например, <code>start_code</code>, <code>end_data</code>).</li>
<li><strong>Особенности</strong>:</li>
<li>Для <strong>пользовательских процессов</strong> <code>mm</code> всегда валиден.</li>
<li><strong>Потоки ядра</strong> (например, kthreadd) не имеют пользовательского адресного пространства, поэтому <code>mm == NULL</code>.</li>
</ul>
<h5 id="struct-mm_struct-active_mm"><strong><code>struct mm_struct *active_mm</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Активное виртуальное адресное пространство, используемое процессором в данный момент.</li>
<li><strong>Особенности</strong>:</li>
<li>Для <strong>пользовательских процессов</strong> <code>active_mm == mm</code>.</li>
<li>Для <strong>потоков ядра</strong>:<ul>
<li>При переключении контекста поток ядра "заимствует" <code>active_mm</code> у предыдущего пользовательского процесса (чтобы не переключать таблицы страниц без необходимости).</li>
<li>Например, если поток ядра выполняется после пользовательского процесса, он использует его <code>active_mm</code>, но не имеет доступа к пользовательской памяти.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="6"><strong>6. Файлы и файловая система</strong></h4>
<ul>
<li><strong><code>struct files_struct *files</code></strong>: Таблица открытых файлов.</li>
<li><strong><code>struct fs_struct *fs</code></strong>: Информация о текущей рабочей и корневой директориях.</li>
</ul>
<hr />
<h4 id="7"><strong>7. Сигналы</strong></h4>
<ul>
<li><strong><code>struct signal_struct *signal</code></strong>: Общая информация о сигналах группы потоков.</li>
<li><strong><code>struct sighand_struct *sighand</code></strong>: Обработчики сигналов.</li>
<li><strong><code>sigset_t blocked</code></strong>: Маска заблокированных сигналов.</li>
<li><strong><code>struct sigpending pending</code></strong>: Ожидающие сигналы.</li>
</ul>
<hr />
<h4 id="8"><strong>8. Учётные данные и права доступа</strong></h4>
<ul>
<li><strong><code>const struct cred *cred</code></strong>: Учётные данные процесса (UID, GID, capabilities).</li>
<li><strong><code>struct cred *real_cred</code></strong>: Учётные данные на момент создания (неизменяемые).</li>
</ul>
<hr />
<h4 id="9"><strong>9. Потоки выполнения</strong></h4>
<h5 id="struct-thread_struct-thread"><strong><code>struct thread_struct thread</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Архитектурно-зависимые данные, сохраняющие состояние процессора при переключении контекста.</li>
<li><strong>Содержимое</strong> (зависит от архитектуры, например, для x86_64):</li>
<li>Регистры общего назначения (<code>rax</code>, <code>rbx</code>, <code>rcx</code> и т.д.).</li>
<li>Сегментные регистры (<code>cs</code>, <code>ds</code>, <code>ss</code>).</li>
<li>Регистр указателя стека (<code>rsp</code>).</li>
<li>Регистр флагов (<code>eflags</code>).</li>
<li>Регистры управления отладкой (<code>debugregs</code>).</li>
<li>Информация о FPU (состояние математического сопроцессора).</li>
<li><strong>Пример использования</strong>:</li>
<li>При переключении задач ядро сохраняет текущее состояние регистров в <code>thread</code> старой задачи и загружает состояние из <code>thread</code> новой задачи.</li>
</ul>
<h5 id="void-stack"><strong><code>void *stack</code></strong></h5>
<ul>
<li><strong>Назначение</strong>: Указатель на <strong>стек ядра</strong> процесса.</li>
<li><strong>Особенности</strong>:</li>
<li>Каждый процесс имеет два стека: <ul>
<li><strong>Стек пользователя</strong>: Используется при выполнении в пользовательском режиме.</li>
<li><strong>Стек ядра</strong>: Выделяется при входе в ядро (например, при системном вызове или прерывании). Именно на него указывает <code>stack</code>.</li>
</ul>
</li>
<li>Размер стека ядра фиксирован (обычно 8 КБ или 16 КБ, зависит от настройки ядра).</li>
<li>Для потоков ядра стек выделяется статически или динамически (например, через <code>vmalloc()</code>).</li>
</ul>
<hr />
<h4 id="10-namespaces"><strong>10. Пространства имён (Namespaces)</strong></h4>
<ul>
<li><strong><code>struct nsproxy *nsproxy</code></strong>: Указатель на пространства имён (PID, сеть, IPC и др.).</li>
</ul>
<hr />
<h4 id="11-cgroups"><strong>11. Контрольные группы (cgroups)</strong></h4>
<ul>
<li><strong><code>struct css_set *cgroups</code></strong>: Связь с контрольными группами для управления ресурсами.</li>
</ul>
<hr />
<h4 id="12"><strong>12. Сетевые параметры</strong></h4>
<ul>
<li><strong><code>struct nsproxy *net_ns</code></strong>: Сетевое пространство имён.</li>
<li><strong><code>struct files_struct *nsproxy</code></strong>: Сокеты и сетевые соединения.</li>
</ul>
<hr />
<h4 id="13"><strong>13. Отладка и трассировка</strong></h4>
<ul>
<li><strong><code>unsigned int ptrace</code></strong>: Флаги для ptrace (например, <code>PTRACE_TRACEME</code>).</li>
<li><strong><code>struct list_head ptrace_entry</code></strong>: Список для трассируемых процессов.</li>
</ul>
<hr />
<h4 id="14"><strong>14. Ресурсы и ограничения</strong></h4>
<ul>
<li><strong><code>struct rlimit rlim[RLIM_NLIMITS]</code></strong>: Ограничения ресурсов (макс. размер файла, CPU время и др.).</li>
<li><strong><code>struct rusage *rusage</code></strong>: Статистика использования ресурсов.</li>
</ul>
<hr />
<h4 id="15"><strong>15. Прочее</strong></h4>
<ul>
<li><strong><code>char comm[TASK_COMM_LEN]</code></strong>: Имя исполняемого файла (максимум 16 байт).</li>
<li><strong><code>int exit_code</code></strong>: Код завершения процесса.</li>
<li><strong><code>struct taskio_accounting ioac</code></strong>: Учёт операций ввода-вывода.</li>
</ul>
<hr />
<h3 id="_14"><strong>Важные замечания</strong></h3>
<ol>
<li><strong>Архитектурная зависимость</strong>: Некоторые поля (например, <code>thread_struct</code>) зависят от процессора.</li>
<li><strong>Версия ядра</strong>: Структура может меняться между версиями ядра. Для точности изучайте исходный код своей версии.</li>
<li><strong>Производительность</strong>: Поля часто оптимизируются для быстрого доступа (выравнивание, кэширование).</li>
<li><strong>Потоки vs. Процессы</strong>: В Linux нет отдельной структуры для потоков — все потоки представлены как <code>task_struct</code>, но с общими <code>mm</code>, <code>files</code>, <code>signal</code> и другими ресурсами.</li>
<li><strong>Состояние <code>TASK_UNINTERRUPTIBLE</code></strong>: Нельзя "убить" процесс в этом состоянии сигналом <code>SIGKILL</code> — он останется в этом состоянии, пока не завершит ожидание (может привести к "зависшим" процессам в <code>D</code> состоянии в <code>ps</code>).</li>
<li><strong>Стек ядра</strong>: Переполнение стека ядра приводит к панике (kernel panic), так как стек небольшой и фиксированного размера.</li>
</ol>
<hr />
<h4 id="_15"><strong>Определение</strong></h4>
<pre><code class="language-c">struct task_struct {
#ifdef CONFIG_THREAD_INFO_IN_TASK
    /*
     * For reasons of header soup (see current_thread_info()), this
     * must be the first element of task_struct.
     */
    struct thread_info      thread_info;
#endif
    unsigned int            __state;

#ifdef CONFIG_PREEMPT_RT
    /* saved state for &quot;spinlock sleepers&quot; */
    unsigned int            saved_state;
#endif

    /*
     * This begins the randomizable portion of task_struct. Only
     * scheduling-critical items should be added above here.
     */
    randomized_struct_fields_start

    void                *stack;
    refcount_t          usage;
    /* Per task flags (PF_*), defined further below: */
    unsigned int            flags;
    unsigned int            ptrace;

#ifdef CONFIG_SMP
    int             on_cpu;
    struct __call_single_node   wake_entry;
    unsigned int            wakee_flips;
    unsigned long           wakee_flip_decay_ts;
    struct task_struct      *last_wakee;

    /*
     * recent_used_cpu is initially set as the last CPU used by a task
     * that wakes affine another task. Waker/wakee relationships can
     * push tasks around a CPU where each wakeup moves to the next one.
     * Tracking a recently used CPU allows a quick search for a recently
     * used CPU that may be idle.
     */
    int             recent_used_cpu;
    int             wake_cpu;
#endif
    int             on_rq;

    int             prio;
    int             static_prio;
    int             normal_prio;
    unsigned int            rt_priority;

    struct sched_entity     se;
    struct sched_rt_entity      rt;
    struct sched_dl_entity      dl;
    const struct sched_class    *sched_class;

#ifdef CONFIG_SCHED_CORE
    struct rb_node          core_node;
    unsigned long           core_cookie;
    unsigned int            core_occupation;
#endif

#ifdef CONFIG_CGROUP_SCHED
    struct task_group       *sched_task_group;
#endif

#ifdef CONFIG_UCLAMP_TASK
    /*
     * Clamp values requested for a scheduling entity.
     * Must be updated with task_rq_lock() held.
     */
    struct uclamp_se        uclamp_req[UCLAMP_CNT];
    /*
     * Effective clamp values used for a scheduling entity.
     * Must be updated with task_rq_lock() held.
     */
    struct uclamp_se        uclamp[UCLAMP_CNT];
#endif

    struct sched_statistics         stats;

#ifdef CONFIG_PREEMPT_NOTIFIERS
    /* List of struct preempt_notifier: */
    struct hlist_head       preempt_notifiers;
#endif

#ifdef CONFIG_BLK_DEV_IO_TRACE
    unsigned int            btrace_seq;
#endif

    unsigned int            policy;
    int             nr_cpus_allowed;
    const cpumask_t         *cpus_ptr;
    cpumask_t           *user_cpus_ptr;
    cpumask_t           cpus_mask;
    void                *migration_pending;
#ifdef CONFIG_SMP
    unsigned short          migration_disabled;
#endif
    unsigned short          migration_flags;

#ifdef CONFIG_PREEMPT_RCU
    int             rcu_read_lock_nesting;
    union rcu_special       rcu_read_unlock_special;
    struct list_head        rcu_node_entry;
    struct rcu_node         *rcu_blocked_node;
#endif /* #ifdef CONFIG_PREEMPT_RCU */

#ifdef CONFIG_TASKS_RCU
    unsigned long           rcu_tasks_nvcsw;
    u8              rcu_tasks_holdout;
    u8              rcu_tasks_idx;
    int             rcu_tasks_idle_cpu;
    struct list_head        rcu_tasks_holdout_list;
#endif /* #ifdef CONFIG_TASKS_RCU */

#ifdef CONFIG_TASKS_TRACE_RCU
    int             trc_reader_nesting;
    int             trc_ipi_to_cpu;
    union rcu_special       trc_reader_special;
    struct list_head        trc_holdout_list;
    struct list_head        trc_blkd_node;
    int             trc_blkd_cpu;
#endif /* #ifdef CONFIG_TASKS_TRACE_RCU */

    struct sched_info       sched_info;

    struct list_head        tasks;
#ifdef CONFIG_SMP
    struct plist_node       pushable_tasks;
    struct rb_node          pushable_dl_tasks;
#endif

    struct mm_struct        *mm;
    struct mm_struct        *active_mm;

#ifdef SPLIT_RSS_COUNTING
    struct task_rss_stat        rss_stat;
#endif
    int             exit_state;
    int             exit_code;
    int             exit_signal;
    /* The signal sent when the parent dies: */
    int             pdeath_signal;
    /* JOBCTL_*, siglock protected: */
    unsigned long           jobctl;

    /* Used for emulating ABI behavior of previous Linux versions: */
    unsigned int            personality;

    /* Scheduler bits, serialized by scheduler locks: */
    unsigned            sched_reset_on_fork:1;
    unsigned            sched_contributes_to_load:1;
    unsigned            sched_migrated:1;
    unsigned            sched_task_hot:1;

    /* Force alignment to the next boundary: */
    unsigned            :0;

    /* Unserialized, strictly 'current' */

    /*
     * This field must not be in the scheduler word above due to wakelist
     * queueing no longer being serialized by p-&gt;on_cpu. However:
     *
     * p-&gt;XXX = X;          ttwu()
     * schedule()             if (p-&gt;on_rq &amp;&amp; ..) // false
     *   smp_mb__after_spinlock();    if (smp_load_acquire(&amp;p-&gt;on_cpu) &amp;&amp; //true
     *   deactivate_task()            ttwu_queue_wakelist())
     *     p-&gt;on_rq = 0;            p-&gt;sched_remote_wakeup = Y;
     *
     * guarantees all stores of 'current' are visible before
     * -&gt;sched_remote_wakeup gets used, so it can be in this word.
     */
    unsigned            sched_remote_wakeup:1;

    /* Bit to tell LSMs we're in execve(): */
    unsigned            in_execve:1;
    unsigned            in_iowait:1;
#ifndef TIF_RESTORE_SIGMASK
    unsigned            restore_sigmask:1;
#endif
#ifdef CONFIG_MEMCG
    unsigned            in_user_fault:1;
#endif
#ifdef CONFIG_LRU_GEN
    /* whether the LRU algorithm may apply to this access */
    unsigned            in_lru_fault:1;
#endif
#ifdef CONFIG_COMPAT_BRK
    unsigned            brk_randomized:1;
#endif
#ifdef CONFIG_CGROUPS
    /* disallow userland-initiated cgroup migration */
    unsigned            no_cgroup_migration:1;
    /* task is frozen/stopped (used by the cgroup freezer) */
    unsigned            frozen:1;
#endif
#ifdef CONFIG_BLK_CGROUP
    unsigned            use_memdelay:1;
#endif
#ifdef CONFIG_PSI
    /* Stalled due to lack of memory */
    unsigned            in_memstall:1;
#endif
#ifdef CONFIG_PAGE_OWNER
    /* Used by page_owner=on to detect recursion in page tracking. */
    unsigned            in_page_owner:1;
#endif
#ifdef CONFIG_EVENTFD
    /* Recursion prevention for eventfd_signal() */
    unsigned            in_eventfd:1;
#endif
#ifdef CONFIG_IOMMU_SVA
    unsigned            pasid_activated:1;
#endif
#ifdef  CONFIG_CPU_SUP_INTEL
    unsigned            reported_split_lock:1;
#endif
#ifdef CONFIG_TASK_DELAY_ACCT
    /* delay due to memory thrashing */
    unsigned                        in_thrashing:1;
#endif

    unsigned long           atomic_flags; /* Flags requiring atomic access. */

    struct restart_block        restart_block;

    pid_t               pid;
    pid_t               tgid;

#ifdef CONFIG_STACKPROTECTOR
    /* Canary value for the -fstack-protector GCC feature: */
    unsigned long           stack_canary;
#endif
    /*
     * Pointers to the (original) parent process, youngest child, younger sibling,
     * older sibling, respectively.  (p-&gt;father can be replaced with
     * p-&gt;real_parent-&gt;pid)
     */

    /* Real parent process: */
    struct task_struct __rcu    *real_parent;

    /* Recipient of SIGCHLD, wait4() reports: */
    struct task_struct __rcu    *parent;

    /*
     * Children/sibling form the list of natural children:
     */
    struct list_head        children;
    struct list_head        sibling;
    struct task_struct      *group_leader;

    /*
     * 'ptraced' is the list of tasks this task is using ptrace() on.
     *
     * This includes both natural children and PTRACE_ATTACH targets.
     * 'ptrace_entry' is this task's link on the p-&gt;parent-&gt;ptraced list.
     */
    struct list_head        ptraced;
    struct list_head        ptrace_entry;

    /* PID/PID hash table linkage. */
    struct pid          *thread_pid;
    struct hlist_node       pid_links[PIDTYPE_MAX];
    struct list_head        thread_group;
    struct list_head        thread_node;

    struct completion       *vfork_done;

    /* CLONE_CHILD_SETTID: */
    int __user          *set_child_tid;

    /* CLONE_CHILD_CLEARTID: */
    int __user          *clear_child_tid;

    /* PF_KTHREAD | PF_IO_WORKER */
    void                *worker_private;

    u64             utime;
    u64             stime;
#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME
    u64             utimescaled;
    u64             stimescaled;
#endif
    u64             gtime;
    struct prev_cputime     prev_cputime;
#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN
    struct vtime            vtime;
#endif

#ifdef CONFIG_NO_HZ_FULL
    atomic_t            tick_dep_mask;
#endif
    /* Context switch counts: */
    unsigned long           nvcsw;
    unsigned long           nivcsw;

    /* Monotonic time in nsecs: */
    u64             start_time;

    /* Boot based time in nsecs: */
    u64             start_boottime;

    /* MM fault and swap info: this can arguably be seen as either mm-specific or thread-specific: */
    unsigned long           min_flt;
    unsigned long           maj_flt;

    /* Empty if CONFIG_POSIX_CPUTIMERS=n */
    struct posix_cputimers      posix_cputimers;

#ifdef CONFIG_POSIX_CPU_TIMERS_TASK_WORK
    struct posix_cputimers_work posix_cputimers_work;
#endif

    /* Process credentials: */

    /* Tracer's credentials at attach: */
    const struct cred __rcu     *ptracer_cred;

    /* Objective and real subjective task credentials (COW): */
    const struct cred __rcu     *real_cred;

    /* Effective (overridable) subjective task credentials (COW): */
    const struct cred __rcu     *cred;

#ifdef CONFIG_KEYS
    /* Cached requested key. */
    struct key          *cached_requested_key;
#endif

    /*
     * executable name, excluding path.
     *
     * - normally initialized setup_new_exec()
     * - access it with [gs]et_task_comm()
     * - lock it with task_lock()
     */
    char                comm[TASK_COMM_LEN];

    struct nameidata        *nameidata;

#ifdef CONFIG_SYSVIPC
    struct sysv_sem         sysvsem;
    struct sysv_shm         sysvshm;
#endif
#ifdef CONFIG_DETECT_HUNG_TASK
    unsigned long           last_switch_count;
    unsigned long           last_switch_time;
#endif
    /* Filesystem information: */
    struct fs_struct        *fs;

    /* Open file information: */
    struct files_struct     *files;

#ifdef CONFIG_IO_URING
    struct io_uring_task        *io_uring;
#endif

    /* Namespaces: */
    struct nsproxy          *nsproxy;

    /* Signal handlers: */
    struct signal_struct        *signal;
    struct sighand_struct __rcu     *sighand;
    sigset_t            blocked;
    sigset_t            real_blocked;
    /* Restored if set_restore_sigmask() was used: */
    sigset_t            saved_sigmask;
    struct sigpending       pending;
    unsigned long           sas_ss_sp;
    size_t              sas_ss_size;
    unsigned int            sas_ss_flags;

    struct callback_head        *task_works;

#ifdef CONFIG_AUDIT
#ifdef CONFIG_AUDITSYSCALL
    struct audit_context        *audit_context;
#endif
    kuid_t              loginuid;
    unsigned int            sessionid;
#endif
    struct seccomp          seccomp;
    struct syscall_user_dispatch    syscall_dispatch;

    /* Thread group tracking: */
    u64             parent_exec_id;
    u64             self_exec_id;

    /* Protection against (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed, mempolicy: */
    spinlock_t          alloc_lock;

    /* Protection of the PI data structures: */
    raw_spinlock_t          pi_lock;

    struct wake_q_node      wake_q;

#ifdef CONFIG_RT_MUTEXES
    /* PI waiters blocked on a rt_mutex held by this task: */
    struct rb_root_cached       pi_waiters;
    /* Updated under owner's pi_lock and rq lock */
    struct task_struct      *pi_top_task;
    /* Deadlock detection and priority inheritance handling: */
    struct rt_mutex_waiter      *pi_blocked_on;
#endif

#ifdef CONFIG_DEBUG_MUTEXES
    /* Mutex deadlock detection: */
    struct mutex_waiter     *blocked_on;
#endif

#ifdef CONFIG_DEBUG_ATOMIC_SLEEP
    int             non_block_count;
#endif

#ifdef CONFIG_TRACE_IRQFLAGS
    struct irqtrace_events      irqtrace;
    unsigned int            hardirq_threaded;
    u64             hardirq_chain_key;
    int             softirqs_enabled;
    int             softirq_context;
    int             irq_config;
#endif
#ifdef CONFIG_PREEMPT_RT
    int             softirq_disable_cnt;
#endif

#ifdef CONFIG_LOCKDEP
# define MAX_LOCK_DEPTH         48UL
    u64             curr_chain_key;
    int             lockdep_depth;
    unsigned int            lockdep_recursion;
    struct held_lock        held_locks[MAX_LOCK_DEPTH];
#endif

#if defined(CONFIG_UBSAN) &amp;&amp; !defined(CONFIG_UBSAN_TRAP)
    unsigned int            in_ubsan;
#endif

    /* Journalling filesystem info: */
    void                *journal_info;

    /* Stacked block device info: */
    struct bio_list         *bio_list;

    /* Stack plugging: */
    struct blk_plug         *plug;

    /* VM state: */
    struct reclaim_state        *reclaim_state;

    struct backing_dev_info     *backing_dev_info;

    struct io_context       *io_context;

#ifdef CONFIG_COMPACTION
    struct capture_control      *capture_control;
#endif
    /* Ptrace state: */
    unsigned long           ptrace_message;
    kernel_siginfo_t        *last_siginfo;

    struct task_io_accounting   ioac;
#ifdef CONFIG_PSI
    /* Pressure stall state */
    unsigned int            psi_flags;
#endif
#ifdef CONFIG_TASK_XACCT
    /* Accumulated RSS usage: */
    u64             acct_rss_mem1;
    /* Accumulated virtual memory usage: */
    u64             acct_vm_mem1;
    /* stime + utime since last update: */
    u64             acct_timexpd;
#endif
#ifdef CONFIG_CPUSETS
    /* Protected by -&gt;alloc_lock: */
    nodemask_t          mems_allowed;
    /* Sequence number to catch updates: */
    seqcount_spinlock_t     mems_allowed_seq;
    int             cpuset_mem_spread_rotor;
    int             cpuset_slab_spread_rotor;
#endif
#ifdef CONFIG_CGROUPS
    /* Control Group info protected by css_set_lock: */
    struct css_set __rcu        *cgroups;
    /* cg_list protected by css_set_lock and tsk-&gt;alloc_lock: */
    struct list_head        cg_list;
#endif
#ifdef CONFIG_X86_CPU_RESCTRL
    u32             closid;
    u32             rmid;
#endif
#ifdef CONFIG_FUTEX
    struct robust_list_head __user  *robust_list;
#ifdef CONFIG_COMPAT
    struct compat_robust_list_head __user *compat_robust_list;
#endif
    struct list_head        pi_state_list;
    struct futex_pi_state       *pi_state_cache;
    struct mutex            futex_exit_mutex;
    unsigned int            futex_state;
#endif
#ifdef CONFIG_PERF_EVENTS
    struct perf_event_context   *perf_event_ctxp[perf_nr_task_contexts];
    struct mutex            perf_event_mutex;
    struct list_head        perf_event_list;
#endif
#ifdef CONFIG_DEBUG_PREEMPT
    unsigned long           preempt_disable_ip;
#endif
#ifdef CONFIG_NUMA
    /* Protected by alloc_lock: */
    struct mempolicy        *mempolicy;
    short               il_prev;
    short               pref_node_fork;
#endif
#ifdef CONFIG_NUMA_BALANCING
    int             numa_scan_seq;
    unsigned int            numa_scan_period;
    unsigned int            numa_scan_period_max;
    int             numa_preferred_nid;
    unsigned long           numa_migrate_retry;
    /* Migration stamp: */
    u64             node_stamp;
    u64             last_task_numa_placement;
    u64             last_sum_exec_runtime;
    struct callback_head        numa_work;

    /*
     * This pointer is only modified for current in syscall and
     * pagefault context (and for tasks being destroyed), so it can be read
     * from any of the following contexts:
     *  - RCU read-side critical section
     *  - current-&gt;numa_group from everywhere
     *  - task's runqueue locked, task not running
     */
    struct numa_group __rcu     *numa_group;

    /*
     * numa_faults is an array split into four regions:
     * faults_memory, faults_cpu, faults_memory_buffer, faults_cpu_buffer
     * in this precise order.
     *
     * faults_memory: Exponential decaying average of faults on a per-node
     * basis. Scheduling placement decisions are made based on these
     * counts. The values remain static for the duration of a PTE scan.
     * faults_cpu: Track the nodes the process was running on when a NUMA
     * hinting fault was incurred.
     * faults_memory_buffer and faults_cpu_buffer: Record faults per node
     * during the current scan window. When the scan completes, the counts
     * in faults_memory and faults_cpu decay and these values are copied.
     */
    unsigned long           *numa_faults;
    unsigned long           total_numa_faults;

    /*
     * numa_faults_locality tracks if faults recorded during the last
     * scan window were remote/local or failed to migrate. The task scan
     * period is adapted based on the locality of the faults with different
     * weights depending on whether they were shared or private faults
     */
    unsigned long           numa_faults_locality[3];

    unsigned long           numa_pages_migrated;
#endif /* CONFIG_NUMA_BALANCING */

#ifdef CONFIG_RSEQ
    struct rseq __user *rseq;
    u32 rseq_sig;
    /*
     * RmW on rseq_event_mask must be performed atomically
     * with respect to preemption.
     */
    unsigned long rseq_event_mask;
#endif

    struct tlbflush_unmap_batch tlb_ubc;

    union {
        refcount_t      rcu_users;
        struct rcu_head     rcu;
    };

    /* Cache last used pipe for splice(): */
    struct pipe_inode_info      *splice_pipe;

    struct page_frag        task_frag;

#ifdef CONFIG_TASK_DELAY_ACCT
    struct task_delay_info      *delays;
#endif

#ifdef CONFIG_FAULT_INJECTION
    int             make_it_fail;
    unsigned int            fail_nth;
#endif
    /*
     * When (nr_dirtied &gt;= nr_dirtied_pause), it's time to call
     * balance_dirty_pages() for a dirty throttling pause:
     */
    int             nr_dirtied;
    int             nr_dirtied_pause;
    /* Start of a write-and-pause period: */
    unsigned long           dirty_paused_when;

#ifdef CONFIG_LATENCYTOP
    int             latency_record_count;
    struct latency_record       latency_record[LT_SAVECOUNT];
#endif
    /*
     * Time slack values; these are used to round up poll() and
     * select() etc timeout values. These are in nanoseconds.
     */
    u64             timer_slack_ns;
    u64             default_timer_slack_ns;

#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)
    unsigned int            kasan_depth;
#endif

#ifdef CONFIG_KCSAN
    struct kcsan_ctx        kcsan_ctx;
#ifdef CONFIG_TRACE_IRQFLAGS
    struct irqtrace_events      kcsan_save_irqtrace;
#endif
#ifdef CONFIG_KCSAN_WEAK_MEMORY
    int             kcsan_stack_depth;
#endif
#endif

#ifdef CONFIG_KMSAN
    struct kmsan_ctx        kmsan_ctx;
#endif

#if IS_ENABLED(CONFIG_KUNIT)
    struct kunit            *kunit_test;
#endif

#ifdef CONFIG_FUNCTION_GRAPH_TRACER
    /* Index of current stored address in ret_stack: */
    int             curr_ret_stack;
    int             curr_ret_depth;

    /* Stack of return addresses for return function tracing: */
    struct ftrace_ret_stack     *ret_stack;

    /* Timestamp for last schedule: */
    unsigned long long      ftrace_timestamp;

    /*
     * Number of functions that haven't been traced
     * because of depth overrun:
     */
    atomic_t            trace_overrun;

    /* Pause tracing: */
    atomic_t            tracing_graph_pause;
#endif

#ifdef CONFIG_TRACING
    /* Bitmask and counter of trace recursion: */
    unsigned long           trace_recursion;
#endif /* CONFIG_TRACING */

#ifdef CONFIG_KCOV
    /* See kernel/kcov.c for more details. */

    /* Coverage collection mode enabled for this task (0 if disabled): */
    unsigned int            kcov_mode;

    /* Size of the kcov_area: */
    unsigned int            kcov_size;

    /* Buffer for coverage collection: */
    void                *kcov_area;

    /* KCOV descriptor wired with this task or NULL: */
    struct kcov         *kcov;

    /* KCOV common handle for remote coverage collection: */
    u64             kcov_handle;

    /* KCOV sequence number: */
    int             kcov_sequence;

    /* Collect coverage from softirq context: */
    unsigned int            kcov_softirq;
#endif

#ifdef CONFIG_MEMCG
    struct mem_cgroup       *memcg_in_oom;
    gfp_t               memcg_oom_gfp_mask;
    int             memcg_oom_order;

    /* Number of pages to reclaim on returning to userland: */
    unsigned int            memcg_nr_pages_over_high;

    /* Used by memcontrol for targeted memcg charge: */
    struct mem_cgroup       *active_memcg;
#endif

#ifdef CONFIG_BLK_CGROUP
    struct request_queue        *throttle_queue;
#endif

#ifdef CONFIG_UPROBES
    struct uprobe_task      *utask;
#endif
#if defined(CONFIG_BCACHE) || defined(CONFIG_BCACHE_MODULE)
    unsigned int            sequential_io;
    unsigned int            sequential_io_avg;
#endif
    struct kmap_ctrl        kmap_ctrl;
#ifdef CONFIG_DEBUG_ATOMIC_SLEEP
    unsigned long           task_state_change;
# ifdef CONFIG_PREEMPT_RT
    unsigned long           saved_state_change;
# endif
#endif
    int             pagefault_disabled;
#ifdef CONFIG_MMU
    struct task_struct      *oom_reaper_list;
    struct timer_list       oom_reaper_timer;
#endif
#ifdef CONFIG_VMAP_STACK
    struct vm_struct        *stack_vm_area;
#endif
#ifdef CONFIG_THREAD_INFO_IN_TASK
    /* A live task holds one reference: */
    refcount_t          stack_refcount;
#endif
#ifdef CONFIG_LIVEPATCH
    int patch_state;
#endif
#ifdef CONFIG_SECURITY
    /* Used by LSM modules for access restriction: */
    void                *security;
#endif
#ifdef CONFIG_BPF_SYSCALL
    /* Used by BPF task local storage */
    struct bpf_local_storage __rcu  *bpf_storage;
    /* Used for BPF run context */
    struct bpf_run_ctx      *bpf_ctx;
#endif

#ifdef CONFIG_GCC_PLUGIN_STACKLEAK
    unsigned long           lowest_stack;
    unsigned long           prev_lowest_stack;
#endif

#ifdef CONFIG_X86_MCE
    void __user         *mce_vaddr;
    __u64               mce_kflags;
    u64             mce_addr;
    __u64               mce_ripv : 1,
                    mce_whole_page : 1,
                    __mce_reserved : 62;
    struct callback_head        mce_kill_me;
    int             mce_count;
#endif

#ifdef CONFIG_KRETPROBES
    struct llist_head               kretprobe_instances;
#endif
#ifdef CONFIG_RETHOOK
    struct llist_head               rethooks;
#endif

#ifdef CONFIG_ARCH_HAS_PARANOID_L1D_FLUSH
    /*
     * If L1D flush is supported on mm context switch
     * then we use this callback head to queue kill work
     * to kill tasks that are not running on SMT disabled
     * cores
     */
    struct callback_head        l1d_flush_kill;
#endif

#ifdef CONFIG_RV
    /*
     * Per-task RV monitor. Nowadays fixed in RV_PER_TASK_MONITORS.
     * If we find justification for more monitors, we can think
     * about adding more or developing a dynamic method. So far,
     * none of these are justified.
     */
    union rv_task_monitor       rv[RV_PER_TASK_MONITORS];
#endif

    /*
     * New fields for task_struct should be added above here, so that
     * they are included in the randomized portion of task_struct.
     */
    randomized_struct_fields_end

    /* CPU-specific state of this task: */
    struct thread_struct        thread;

    /*
     * WARNING: on x86, 'thread_struct' contains a variable-sized
     * structure.  It *MUST* be at the end of 'task_struct'.
     *
     * Do not put anything below here!
     */
};

static inline struct pid *task_pid(struct task_struct *task)
{
    return task-&gt;thread_pid;
}

/*
 * the helpers to get the task's different pids as they are seen
 * from various namespaces
 *
 * task_xid_nr()     : global id, i.e. the id seen from the init namespace;
 * task_xid_vnr()    : virtual id, i.e. the id seen from the pid namespace of
 *                     current.
 * task_xid_nr_ns()  : id seen from the ns specified;
 *
 * see also pid_nr() etc in include/linux/pid.h
 */
pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type, struct pid_namespace *ns);

static inline pid_t task_pid_nr(struct task_struct *tsk)
{
    return tsk-&gt;pid;
}

static inline pid_t task_pid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_PID, ns);
}

static inline pid_t task_pid_vnr(struct task_struct *tsk)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_PID, NULL);
}


static inline pid_t task_tgid_nr(struct task_struct *tsk)
{
    return tsk-&gt;tgid;
}

/**
 * pid_alive - check that a task structure is not stale
 * @p: Task structure to be checked.
 *
 * Test if a process is not yet dead (at most zombie state)
 * If pid_alive fails, then pointers within the task structure
 * can be stale and must not be dereferenced.
 *
 * Return: 1 if the process is alive. 0 otherwise.
 */
static inline int pid_alive(const struct task_struct *p)
{
    return p-&gt;thread_pid != NULL;
}

static inline pid_t task_pgrp_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_PGID, ns);
}

static inline pid_t task_pgrp_vnr(struct task_struct *tsk)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_PGID, NULL);
}


static inline pid_t task_session_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_SID, ns);
}

static inline pid_t task_session_vnr(struct task_struct *tsk)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_SID, NULL);
}

static inline pid_t task_tgid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_TGID, ns);
}

static inline pid_t task_tgid_vnr(struct task_struct *tsk)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_TGID, NULL);
}

static inline pid_t task_ppid_nr_ns(const struct task_struct *tsk, struct pid_namespace *ns)
{
    pid_t pid = 0;

    rcu_read_lock();
    if (pid_alive(tsk))
        pid = task_tgid_nr_ns(rcu_dereference(tsk-&gt;real_parent), ns);
    rcu_read_unlock();

    return pid;
}

static inline pid_t task_ppid_nr(const struct task_struct *tsk)
{
    return task_ppid_nr_ns(tsk, &amp;init_pid_ns);
}

/* Obsolete, do not use: */
static inline pid_t task_pgrp_nr(struct task_struct *tsk)
{
    return task_pgrp_nr_ns(tsk, &amp;init_pid_ns);
}

</code></pre>
<hr />
<h4 id="_16"><strong>Пример</strong></h4>
<p>Модуль выводит информацию о текущем процессе, его родителе и всех запущенных процессах в системе.</p>
<pre><code class="language-c">
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/sched/signal.h&gt; // Для доступа к for_each_process()
#include &lt;linux/sched.h&gt;        // Для task_struct

MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;OldALoneFag&quot;);
MODULE_DESCRIPTION(&quot;Task_struct demo module&quot;);

// Вывод информации о процессе
static void print_task_info(struct task_struct *task) {
    char state_str[32];

    // Преобразуем состояние процесса в строку
    switch (task-&gt;__state) {
        case TASK_RUNNING:          strcpy(state_str, &quot;RUNNING&quot;); break;
        case TASK_INTERRUPTIBLE:    strcpy(state_str, &quot;INTERRUPTIBLE&quot;); break;
        case TASK_UNINTERRUPTIBLE:  strcpy(state_str, &quot;UNINTERRUPTIBLE&quot;); break;
        case __TASK_STOPPED:        strcpy(state_str, &quot;STOPPED&quot;); break;
        default:                    snprintf(state_str, 32, &quot;UNKNOWN (%ld)&quot;, task-&gt;__state);
    }

    printk(KERN_INFO
        &quot;PID: %d | PPID: %d | Name: %-16s | State: %-16s | TGID: %d | CPU: %d\n&quot;,
        task-&gt;pid,
        task-&gt;parent-&gt;pid,
        task-&gt;comm,
        state_str,
        task-&gt;tgid,
        task-&gt;cpu
    );
}

// Вывод информации о текущем процессе
static void print_current_task_info(void) {
    struct task_struct *current_task = current;

    printk(KERN_INFO &quot;\n=== Current Task ===\n&quot;);
    print_task_info(current_task);
    printk(KERN_INFO &quot;Start time: %llu ns\n&quot;, current_task-&gt;start_time);
}

// Обход всех процессов в системе
static void list_all_processes(void) {
    struct task_struct *task;

    printk(KERN_INFO &quot;\n=== All Processes ===\n&quot;);

    rcu_read_lock(); // Блокировка RCU для безопасного обхода
    for_each_process(task) {
        print_task_info(task);
    }
    rcu_read_unlock();
}

static int __init task_info_init(void) {
    printk(KERN_INFO &quot;Task Info Module: Loaded\n&quot;);

    // Информация о текущем процессе (insmod/modprobe)
    print_current_task_info();

    // Список всех процессов
    list_all_processes();

    return 0;
}

static void __exit task_info_exit(void) {
    printk(KERN_INFO &quot;Task Info Module: Unloaded\n&quot;);
}

module_init(task_info_init);
module_exit(task_info_exit);

</code></pre>
<h4 id="_17"><strong>Пояснения к примеру:</strong></h4>
<ol>
<li><strong><code>print_task_info</code></strong>:</li>
<li>
<p>Выводит ключевые поля <code>task_struct</code>:</p>
<ul>
<li><code>pid</code> — идентификатор процесса</li>
<li><code>parent-&gt;pid</code> — PID родителя</li>
<li><code>comm</code> — имя исполняемого файла (до 16 символов)</li>
<li><code>__state</code> — состояние процесса</li>
<li><code>tgid</code> — идентификатор группы потоков</li>
<li><code>cpu</code> — номер CPU, на котором выполняется процесс</li>
</ul>
</li>
<li>
<p><strong><code>print_current_task_info</code></strong>:</p>
</li>
<li>Использует <code>current</code> для получения текущего процесса (которым будет <code>insmod</code> или <code>modprobe</code> при загрузке модуля).</li>
<li>
<p>Добавляет вывод времени старта (<code>start_time</code>).</p>
</li>
<li>
<p><strong><code>list_all_processes</code></strong>:</p>
</li>
<li>Использует <code>for_each_process()</code> для итерации по всем процессам в системе.</li>
<li><code>rcu_read_lock()</code> гарантирует безопасность при обходе.</li>
</ol>
<hr />
<p>Структура <code>task_struct</code> — это сердце управления процессами в Linux. Её сложность отражает многообразие функций, которые ядро выполняет для обеспечения работы системы.</p>
<h2 id="linux_2">Процесс создания процесса в Linux</h2>
<p>При создании процесса операционная система выполняет следующие действия:</p>
<ol>
<li>Загружает код программы и статические данные в память</li>
<li>Выделяет память под стек</li>
<li>Инициализирует регистры процессора</li>
<li>Устанавливает начальные настройки ввода-вывода(stdin, stdout, stderr)</li>
<li>Передает управление точке входа программы (main()) </li>
</ol>
<h3 id="fork">Реализация системного вызова fork</h3>
<p>В файле <code>kernel/fork.c</code> находится основная реализация системного вызова fork:</p>
<pre><code class="language-c">#ifdef __ARCH_WANT_SYS_FORK
SYSCALL_DEFINE0(fork)
{
#ifdef CONFIG_MMU
    struct kernel_clone_args args = {
        .exit_signal = SIGCHLD,
    };

    return kernel_clone(&amp;args);
#else
    /* can not support in nommu mode */
    return -EINVAL;
#endif
}

</code></pre>
<p>Код начинается с двух <code>#ifdef</code>:</p>
<ol>
<li><code>#ifdef __ARCH_WANT_SYS_FORK</code> - проверяет, поддерживает ли архитектура системный вызов fork. Это позволяет архитектурам, которые не поддерживают fork (например, некоторые встраиваемые системы), исключить его реализацию из ядра.</li>
<li><code>#ifdef CONFIG_MMU</code> - проверяет наличие Memory Management Unit (MMU) в системе. MMU необходим для работы с виртуальной памятью и создания отдельных адресных пространств для процессов.</li>
</ol>
<p>В случае наличия MMU выполняется следующая последовательность действий:</p>
<ol>
<li>Создается структура <code>struct kernel_clone_args</code> с одним полем:</li>
<li>
<p><code>.exit_signal = SIGCHLD</code> - этот сигнал будет отправлен родительскому процессу при завершении дочернего процесса. SIGCHLD используется для уведомления родителя о изменениях состояния дочерних процессов.</p>
</li>
<li>
<p>Вызывается функция <code>kernel_clone()</code>, которая выполняет основную работу по созданию нового процесса.</p>
</li>
</ol>
<h3 id="clone">Реализация clone</h3>
<pre><code class="language-c">/*
 *  Ok, this is the main fork-routine.
 *
 * It copies the process, and if successful kick-starts
 * it and waits for it to finish using the VM if required.
 *
 * args-&gt;exit_signal is expected to be checked for sanity by the caller.
 */
pid_t kernel_clone(struct kernel_clone_args *args)
{
    u64 clone_flags = args-&gt;flags;
    struct completion vfork;
    struct pid *pid;
    struct task_struct *p;
    int trace = 0;
    pid_t nr;

    /*
     * For legacy clone() calls, CLONE_PIDFD uses the parent_tid argument
     * to return the pidfd. Hence, CLONE_PIDFD and CLONE_PARENT_SETTID are
     * mutually exclusive. With clone3() CLONE_PIDFD has grown a separate
     * field in struct clone_args and it still doesn't make sense to have
     * them both point at the same memory location. Performing this check
     * here has the advantage that we don't need to have a separate helper
     * to check for legacy clone().
     */
    if ((args-&gt;flags &amp; CLONE_PIDFD) &amp;&amp;
        (args-&gt;flags &amp; CLONE_PARENT_SETTID) &amp;&amp;
        (args-&gt;pidfd == args-&gt;parent_tid))
        return -EINVAL;

    /*
     * Determine whether and which event to report to ptracer.  When
     * called from kernel_thread or CLONE_UNTRACED is explicitly
     * requested, no event is reported; otherwise, report if the event
     * for the type of forking is enabled.
     */
    if (!(clone_flags &amp; CLONE_UNTRACED)) {
        if (clone_flags &amp; CLONE_VFORK)
            trace = PTRACE_EVENT_VFORK;
        else if (args-&gt;exit_signal != SIGCHLD)
            trace = PTRACE_EVENT_CLONE;
        else
            trace = PTRACE_EVENT_FORK;

        if (likely(!ptrace_event_enabled(current, trace)))
            trace = 0;
    }

    p = copy_process(NULL, trace, NUMA_NO_NODE, args);
    add_latent_entropy();

    if (IS_ERR(p))
        return PTR_ERR(p);

    /*
     * Do this prior waking up the new thread - the thread pointer
     * might get invalid after that point, if the thread exits quickly.
     */
    trace_sched_process_fork(current, p);

    pid = get_task_pid(p, PIDTYPE_PID);
    nr = pid_vnr(pid);

    if (clone_flags &amp; CLONE_PARENT_SETTID)
        put_user(nr, args-&gt;parent_tid);

    if (clone_flags &amp; CLONE_VFORK) {
        p-&gt;vfork_done = &amp;vfork;
        init_completion(&amp;vfork);
        get_task_struct(p);
    }

    if (IS_ENABLED(CONFIG_LRU_GEN) &amp;&amp; !(clone_flags &amp; CLONE_VM)) {
        /* lock the task to synchronize with memcg migration */
        task_lock(p);
        lru_gen_add_mm(p-&gt;mm);
        task_unlock(p);
    }

    wake_up_new_task(p);

    /* forking complete and child started to run, tell ptracer */
    if (unlikely(trace))
        ptrace_event_pid(trace, pid);

    if (clone_flags &amp; CLONE_VFORK) {
        if (!wait_for_vfork_done(p, &amp;vfork))
            ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);
    }

    put_pid(pid);
    return nr;
}

</code></pre>
<p>Функция принимает один аргумент типа <code>struct kernel_clone_args *args</code>, содержащий флаги и параметры клонирования. Она возвращает идентификатор процесса (PID) нового процесса или код ошибки.</p>
<p>Предварительные проверки и подготовка</p>
<pre><code class="language-c">u64 clone_flags = args-&gt;flags;
struct completion vfork;
struct pid *pid;
struct task_struct *p;
int trace = 0;
pid_t nr;
</code></pre>
<ul>
<li>Сохраняет флаги клонирования в локальной переменной</li>
<li>Инициализирует структуры для отслеживания состояния vfork</li>
<li>Подготавливает переменные для идентификаторов процесса</li>
</ul>
<p>Проверка валидности флагов</p>
<pre><code class="language-c">if ((args-&gt;flags &amp; CLONE_PIDFD) &amp;&amp;
    (args-&gt;flags &amp; CLONE_PARENT_SETTID) &amp;&amp;
    (args-&gt;pidfd == args-&gt;parent_tid))
    return -EINVAL;
</code></pre>
<ul>
<li>Проверяет взаимную исключаемость флагов CLONE_PIDFD и CLONE_PARENT_SETTID</li>
<li>Предотвращает конфликт при совместном использовании этих флагов</li>
</ul>
<p>Настройка отслеживания ptrace</p>
<pre><code class="language-c">if (!(clone_flags &amp; CLONE_UNTRACED)) {
    if (clone_flags &amp; CLONE_VFORK)
        trace = PTRACE_EVENT_VFORK;
    else if (args-&gt;exit_signal != SIGCHLD)
        trace = PTRACE_EVENT_CLONE;
    else
        trace = PTRACE_EVENT_FORK;
</code></pre>
<ul>
<li>Определяет тип события для отслеживания ptrace</li>
<li>Устанавливает соответствующий тип события в зависимости от флагов клонирования</li>
</ul>
<p>Создание нового процесса</p>
<pre><code class="language-c">p = copy_process(NULL, trace, NUMA_NO_NODE, args);
add_latent_entropy();

if (IS_ERR(p))
    return PTR_ERR(p);
</code></pre>
<ul>
<li>Вызывает функцию copy_process для создания нового процесса</li>
<li>Добавляет энтропию в систему после успешного создания</li>
<li>Проверяет и возвращает ошибку при неудачном создании</li>
</ul>
<p>Настройка идентификаторов и отслеживания</p>
<pre><code class="language-c">pid = get_task_pid(p, PIDTYPE_PID);
nr = pid_vnr(pid);

if (clone_flags &amp; CLONE_PARENT_SETTID)
    put_user(nr, args-&gt;parent_tid);
</code></pre>
<ul>
<li>Получает идентификатор процесса для нового потока</li>
<li>Устанавливает идентификатор родительского процесса при необходимости</li>
</ul>
<p>Обработка специальных случаев vfork</p>
<pre><code class="language-c">if (clone_flags &amp; CLONE_VFORK) {
    p-&gt;vfork_done = &amp;vfork;
    init_completion(&amp;vfork);
    get_task_struct(p);
}
</code></pre>
<ul>
<li>Настройка механизма ожидания для операции vfork</li>
<li>Инициализация структуры для синхронизации между родительским и дочерним процессами</li>
</ul>
<p>Запуск нового процесса</p>
<pre><code class="language-c">wake_up_new_task(p);

if (unlikely(trace))
    ptrace_event_pid(trace, pid);

if (clone_flags &amp; CLONE_VFORK) {
    if (!wait_for_vfork_done(p, &amp;vfork))
        ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);
}

</code></pre>
<ul>
<li>Активирует новый процесс для выполнения</li>
<li>Уведомляет отслеживающие процессы о создании нового процесса</li>
<li>Обрабатывает специфичные для vfork события</li>
</ul>
<p>Завершение и очистка</p>
<pre><code class="language-c">put_pid(pid);
return nr;
</code></pre>
<ul>
<li>Освобождает ресурсы, связанные с идентификатором процесса</li>
<li>Возвращает номер PID нового процесса</li>
</ul>
<h3 id="copy_process">Реализация copy_process</h3>
<pre><code class="language-c">static __latent_entropy struct task_struct *copy_process(
                    struct pid *pid,
                    int trace,
                    int node,
                    struct kernel_clone_args *args)
{
    int pidfd = -1, retval;
    struct task_struct *p;
    struct multiprocess_signals delayed;
    struct file *pidfile = NULL;
    const u64 clone_flags = args-&gt;flags;
    struct nsproxy *nsp = current-&gt;nsproxy;

    /*
     * Don't allow sharing the root directory with processes in a different
     * namespace
     */
    if ((clone_flags &amp; (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
        return ERR_PTR(-EINVAL);

    if ((clone_flags &amp; (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))
        return ERR_PTR(-EINVAL);

    /*
     * Thread groups must share signals as well, and detached threads
     * can only be started up within the thread group.
     */
    if ((clone_flags &amp; CLONE_THREAD) &amp;&amp; !(clone_flags &amp; CLONE_SIGHAND))
        return ERR_PTR(-EINVAL);

    /*
     * Shared signal handlers imply shared VM. By way of the above,
     * thread groups also imply shared VM. Blocking this case allows
     * for various simplifications in other code.
     */
    if ((clone_flags &amp; CLONE_SIGHAND) &amp;&amp; !(clone_flags &amp; CLONE_VM))
        return ERR_PTR(-EINVAL);

    /*
     * Siblings of global init remain as zombies on exit since they are
     * not reaped by their parent (swapper). To solve this and to avoid
     * multi-rooted process trees, prevent global and container-inits
     * from creating siblings.
     */
    if ((clone_flags &amp; CLONE_PARENT) &amp;&amp;
                current-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE)
        return ERR_PTR(-EINVAL);

    /*
     * If the new process will be in a different pid or user namespace
     * do not allow it to share a thread group with the forking task.
     */
    if (clone_flags &amp; CLONE_THREAD) {
        if ((clone_flags &amp; (CLONE_NEWUSER | CLONE_NEWPID)) ||
            (task_active_pid_ns(current) != nsp-&gt;pid_ns_for_children))
            return ERR_PTR(-EINVAL);
    }

    /*
     * If the new process will be in a different time namespace
     * do not allow it to share VM or a thread group with the forking task.
     */
    if (clone_flags &amp; (CLONE_THREAD | CLONE_VM)) {
        if (nsp-&gt;time_ns != nsp-&gt;time_ns_for_children)
            return ERR_PTR(-EINVAL);
    }

    if (clone_flags &amp; CLONE_PIDFD) {
        /*
         * - CLONE_DETACHED is blocked so that we can potentially
         *   reuse it later for CLONE_PIDFD.
         * - CLONE_THREAD is blocked until someone really needs it.
         */
        if (clone_flags &amp; (CLONE_DETACHED | CLONE_THREAD))
            return ERR_PTR(-EINVAL);
    }

    /*
     * Force any signals received before this point to be delivered
     * before the fork happens.  Collect up signals sent to multiple
     * processes that happen during the fork and delay them so that
     * they appear to happen after the fork.
     */
    sigemptyset(&amp;delayed.signal);
    INIT_HLIST_NODE(&amp;delayed.node);

    spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);
    if (!(clone_flags &amp; CLONE_THREAD))
        hlist_add_head(&amp;delayed.node, &amp;current-&gt;signal-&gt;multiprocess);
    recalc_sigpending();
    spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);
    retval = -ERESTARTNOINTR;
    if (task_sigpending(current))
        goto fork_out;

    retval = -ENOMEM;
    p = dup_task_struct(current, node);
    if (!p)
        goto fork_out;
    p-&gt;flags &amp;= ~PF_KTHREAD;
    if (args-&gt;kthread)
        p-&gt;flags |= PF_KTHREAD;
    if (args-&gt;io_thread) {
        /*
         * Mark us an IO worker, and block any signal that isn't
         * fatal or STOP
         */
        p-&gt;flags |= PF_IO_WORKER;
        siginitsetinv(&amp;p-&gt;blocked, sigmask(SIGKILL)|sigmask(SIGSTOP));
    }

    p-&gt;set_child_tid = (clone_flags &amp; CLONE_CHILD_SETTID) ? args-&gt;child_tid : NULL;
    /*
     * Clear TID on mm_release()?
     */
    p-&gt;clear_child_tid = (clone_flags &amp; CLONE_CHILD_CLEARTID) ? args-&gt;child_tid : NULL;

    ftrace_graph_init_task(p);

    rt_mutex_init_task(p);

    lockdep_assert_irqs_enabled();
#ifdef CONFIG_PROVE_LOCKING
    DEBUG_LOCKS_WARN_ON(!p-&gt;softirqs_enabled);
#endif
    retval = copy_creds(p, clone_flags);
    if (retval &lt; 0)
        goto bad_fork_free;

    retval = -EAGAIN;
    if (is_rlimit_overlimit(task_ucounts(p), UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC))) {
        if (p-&gt;real_cred-&gt;user != INIT_USER &amp;&amp;
            !capable(CAP_SYS_RESOURCE) &amp;&amp; !capable(CAP_SYS_ADMIN))
            goto bad_fork_cleanup_count;
    }
    current-&gt;flags &amp;= ~PF_NPROC_EXCEEDED;

    /*
     * If multiple threads are within copy_process(), then this check
     * triggers too late. This doesn't hurt, the check is only there
     * to stop root fork bombs.
     */
    retval = -EAGAIN;
    if (data_race(nr_threads &gt;= max_threads))
        goto bad_fork_cleanup_count;

    delayacct_tsk_init(p);  /* Must remain after dup_task_struct() */
    p-&gt;flags &amp;= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE | PF_NO_SETAFFINITY);
    p-&gt;flags |= PF_FORKNOEXEC;
    INIT_LIST_HEAD(&amp;p-&gt;children);
    INIT_LIST_HEAD(&amp;p-&gt;sibling);
    rcu_copy_process(p);
    p-&gt;vfork_done = NULL;
    spin_lock_init(&amp;p-&gt;alloc_lock);

    init_sigpending(&amp;p-&gt;pending);

    p-&gt;utime = p-&gt;stime = p-&gt;gtime = 0;
#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME
    p-&gt;utimescaled = p-&gt;stimescaled = 0;
#endif
    prev_cputime_init(&amp;p-&gt;prev_cputime);

#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN
    seqcount_init(&amp;p-&gt;vtime.seqcount);
    p-&gt;vtime.starttime = 0;
    p-&gt;vtime.state = VTIME_INACTIVE;
#endif

#ifdef CONFIG_IO_URING
    p-&gt;io_uring = NULL;
#endif

#if defined(SPLIT_RSS_COUNTING)
    memset(&amp;p-&gt;rss_stat, 0, sizeof(p-&gt;rss_stat));
#endif

    p-&gt;default_timer_slack_ns = current-&gt;timer_slack_ns;

#ifdef CONFIG_PSI
    p-&gt;psi_flags = 0;
#endif

    task_io_accounting_init(&amp;p-&gt;ioac);
    acct_clear_integrals(p);

    posix_cputimers_init(&amp;p-&gt;posix_cputimers);
    tick_dep_init_task(p);

    p-&gt;io_context = NULL;
    audit_set_context(p, NULL);
    cgroup_fork(p);
    if (args-&gt;kthread) {
        if (!set_kthread_struct(p))
            goto bad_fork_cleanup_delayacct;
    }
#ifdef CONFIG_NUMA
    p-&gt;mempolicy = mpol_dup(p-&gt;mempolicy);
    if (IS_ERR(p-&gt;mempolicy)) {
        retval = PTR_ERR(p-&gt;mempolicy);
        p-&gt;mempolicy = NULL;
        goto bad_fork_cleanup_delayacct;
    }
#endif
#ifdef CONFIG_CPUSETS
    p-&gt;cpuset_mem_spread_rotor = NUMA_NO_NODE;
    p-&gt;cpuset_slab_spread_rotor = NUMA_NO_NODE;
    seqcount_spinlock_init(&amp;p-&gt;mems_allowed_seq, &amp;p-&gt;alloc_lock);
#endif
#ifdef CONFIG_TRACE_IRQFLAGS
    memset(&amp;p-&gt;irqtrace, 0, sizeof(p-&gt;irqtrace));
    p-&gt;irqtrace.hardirq_disable_ip  = _THIS_IP_;
    p-&gt;irqtrace.softirq_enable_ip   = _THIS_IP_;
    p-&gt;softirqs_enabled     = 1;
    p-&gt;softirq_context      = 0;
#endif

    p-&gt;pagefault_disabled = 0;

#ifdef CONFIG_LOCKDEP
    lockdep_init_task(p);
#endif

#ifdef CONFIG_DEBUG_MUTEXES
    p-&gt;blocked_on = NULL; /* not blocked yet */
#endif
#ifdef CONFIG_BCACHE
    p-&gt;sequential_io    = 0;
    p-&gt;sequential_io_avg    = 0;
#endif
#ifdef CONFIG_BPF_SYSCALL
    RCU_INIT_POINTER(p-&gt;bpf_storage, NULL);
    p-&gt;bpf_ctx = NULL;
#endif

    /* Perform scheduler related setup. Assign this task to a CPU. */
    retval = sched_fork(clone_flags, p);
    if (retval)
        goto bad_fork_cleanup_policy;

    retval = perf_event_init_task(p, clone_flags);
    if (retval)
        goto bad_fork_cleanup_policy;
    retval = audit_alloc(p);
    if (retval)
        goto bad_fork_cleanup_perf;
    /* copy all the process information */
    shm_init_task(p);
    retval = security_task_alloc(p, clone_flags);
    if (retval)
        goto bad_fork_cleanup_audit;
    retval = copy_semundo(clone_flags, p);
    if (retval)
        goto bad_fork_cleanup_security;
    retval = copy_files(clone_flags, p);
    if (retval)
        goto bad_fork_cleanup_semundo;
    retval = copy_fs(clone_flags, p);
    if (retval)
        goto bad_fork_cleanup_files;
    retval = copy_sighand(clone_flags, p);
    if (retval)
        goto bad_fork_cleanup_fs;
    retval = copy_signal(clone_flags, p);
    if (retval)
        goto bad_fork_cleanup_sighand;
    retval = copy_mm(clone_flags, p);
    if (retval)
        goto bad_fork_cleanup_signal;
    retval = copy_namespaces(clone_flags, p);
    if (retval)
        goto bad_fork_cleanup_mm;
    retval = copy_io(clone_flags, p);
    if (retval)
        goto bad_fork_cleanup_namespaces;
    retval = copy_thread(p, args);
    if (retval)
        goto bad_fork_cleanup_io;

    stackleak_task_init(p);

    if (pid != &amp;init_struct_pid) {
        pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns_for_children, args-&gt;set_tid,
                args-&gt;set_tid_size);
        if (IS_ERR(pid)) {
            retval = PTR_ERR(pid);
            goto bad_fork_cleanup_thread;
        }
    }

    /*
     * This has to happen after we've potentially unshared the file
     * descriptor table (so that the pidfd doesn't leak into the child
     * if the fd table isn't shared).
     */
    if (clone_flags &amp; CLONE_PIDFD) {
        retval = get_unused_fd_flags(O_RDWR | O_CLOEXEC);
        if (retval &lt; 0)
            goto bad_fork_free_pid;

        pidfd = retval;

        pidfile = anon_inode_getfile(&quot;[pidfd]&quot;, &amp;pidfd_fops, pid,
                          O_RDWR | O_CLOEXEC);
        if (IS_ERR(pidfile)) {
            put_unused_fd(pidfd);
            retval = PTR_ERR(pidfile);
            goto bad_fork_free_pid;
        }
        get_pid(pid);   /* held by pidfile now */

        retval = put_user(pidfd, args-&gt;pidfd);
        if (retval)
            goto bad_fork_put_pidfd;
    }

#ifdef CONFIG_BLOCK
    p-&gt;plug = NULL;
#endif
    futex_init_task(p);

    /*
     * sigaltstack should be cleared when sharing the same VM
     */
    if ((clone_flags &amp; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)
        sas_ss_reset(p);

    /*
     * Syscall tracing and stepping should be turned off in the
     * child regardless of CLONE_PTRACE.
     */
    user_disable_single_step(p);
    clear_task_syscall_work(p, SYSCALL_TRACE);
#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)
    clear_task_syscall_work(p, SYSCALL_EMU);
#endif
    clear_tsk_latency_tracing(p);

    /* ok, now we should be set up.. */
    p-&gt;pid = pid_nr(pid);
    if (clone_flags &amp; CLONE_THREAD) {
        p-&gt;group_leader = current-&gt;group_leader;
        p-&gt;tgid = current-&gt;tgid;
    } else {
        p-&gt;group_leader = p;
        p-&gt;tgid = p-&gt;pid;
    }

    p-&gt;nr_dirtied = 0;
    p-&gt;nr_dirtied_pause = 128 &gt;&gt; (PAGE_SHIFT - 10);
    p-&gt;dirty_paused_when = 0;

    p-&gt;pdeath_signal = 0;
    INIT_LIST_HEAD(&amp;p-&gt;thread_group);
    p-&gt;task_works = NULL;
    clear_posix_cputimers_work(p);

#ifdef CONFIG_KRETPROBES
    p-&gt;kretprobe_instances.first = NULL;
#endif
#ifdef CONFIG_RETHOOK
    p-&gt;rethooks.first = NULL;
#endif

    /*
     * Ensure that the cgroup subsystem policies allow the new process to be
     * forked. It should be noted that the new process's css_set can be changed
     * between here and cgroup_post_fork() if an organisation operation is in
     * progress.
     */
    retval = cgroup_can_fork(p, args);
    if (retval)
        goto bad_fork_put_pidfd;

    /*
     * Now that the cgroups are pinned, re-clone the parent cgroup and put
     * the new task on the correct runqueue. All this *before* the task
     * becomes visible.
     *
     * This isn't part of -&gt;can_fork() because while the re-cloning is
     * cgroup specific, it unconditionally needs to place the task on a
     * runqueue.
     */
    sched_cgroup_fork(p, args);

    /*
     * From this point on we must avoid any synchronous user-space
     * communication until we take the tasklist-lock. In particular, we do
     * not want user-space to be able to predict the process start-time by
     * stalling fork(2) after we recorded the start_time but before it is
     * visible to the system.
     */

    p-&gt;start_time = ktime_get_ns();
    p-&gt;start_boottime = ktime_get_boottime_ns();

    /*
     * Make it visible to the rest of the system, but dont wake it up yet.
     * Need tasklist lock for parent etc handling!
     */
    write_lock_irq(&amp;tasklist_lock);

    /* CLONE_PARENT re-uses the old parent */
    if (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) {
        p-&gt;real_parent = current-&gt;real_parent;
        p-&gt;parent_exec_id = current-&gt;parent_exec_id;
        if (clone_flags &amp; CLONE_THREAD)
            p-&gt;exit_signal = -1;
        else
            p-&gt;exit_signal = current-&gt;group_leader-&gt;exit_signal;
    } else {
        p-&gt;real_parent = current;
        p-&gt;parent_exec_id = current-&gt;self_exec_id;
        p-&gt;exit_signal = args-&gt;exit_signal;
    }

    klp_copy_process(p);

    sched_core_fork(p);

    spin_lock(&amp;current-&gt;sighand-&gt;siglock);

    rv_task_fork(p);

    rseq_fork(p, clone_flags);

    /* Don't start children in a dying pid namespace */
    if (unlikely(!(ns_of_pid(pid)-&gt;pid_allocated &amp; PIDNS_ADDING))) {
        retval = -ENOMEM;
        goto bad_fork_cancel_cgroup;
    }

    /* Let kill terminate clone/fork in the middle */
    if (fatal_signal_pending(current)) {
        retval = -EINTR;
        goto bad_fork_cancel_cgroup;
    }

    /* No more failure paths after this point. */

    /*
     * Copy seccomp details explicitly here, in case they were changed
     * before holding sighand lock.
     */
    copy_seccomp(p);

    init_task_pid_links(p);
    if (likely(p-&gt;pid)) {
        ptrace_init_task(p, (clone_flags &amp; CLONE_PTRACE) || trace);

        init_task_pid(p, PIDTYPE_PID, pid);
        if (thread_group_leader(p)) {
            init_task_pid(p, PIDTYPE_TGID, pid);
            init_task_pid(p, PIDTYPE_PGID, task_pgrp(current));
            init_task_pid(p, PIDTYPE_SID, task_session(current));

            if (is_child_reaper(pid)) {
                ns_of_pid(pid)-&gt;child_reaper = p;
                p-&gt;signal-&gt;flags |= SIGNAL_UNKILLABLE;
            }
            p-&gt;signal-&gt;shared_pending.signal = delayed.signal;
            p-&gt;signal-&gt;tty = tty_kref_get(current-&gt;signal-&gt;tty);
            /*
             * Inherit has_child_subreaper flag under the same
             * tasklist_lock with adding child to the process tree
             * for propagate_has_child_subreaper optimization.
             */
            p-&gt;signal-&gt;has_child_subreaper = p-&gt;real_parent-&gt;signal-&gt;has_child_subreaper ||
                             p-&gt;real_parent-&gt;signal-&gt;is_child_subreaper;
            list_add_tail(&amp;p-&gt;sibling, &amp;p-&gt;real_parent-&gt;children);
            list_add_tail_rcu(&amp;p-&gt;tasks, &amp;init_task.tasks);
            attach_pid(p, PIDTYPE_TGID);
            attach_pid(p, PIDTYPE_PGID);
            attach_pid(p, PIDTYPE_SID);
            __this_cpu_inc(process_counts);
        } else {
            current-&gt;signal-&gt;nr_threads++;
            current-&gt;signal-&gt;quick_threads++;
            atomic_inc(&amp;current-&gt;signal-&gt;live);
            refcount_inc(&amp;current-&gt;signal-&gt;sigcnt);
            task_join_group_stop(p);
            list_add_tail_rcu(&amp;p-&gt;thread_group,
                      &amp;p-&gt;group_leader-&gt;thread_group);
            list_add_tail_rcu(&amp;p-&gt;thread_node,
                      &amp;p-&gt;signal-&gt;thread_head);
        }
        attach_pid(p, PIDTYPE_PID);
        nr_threads++;
    }
    total_forks++;
    hlist_del_init(&amp;delayed.node);
    spin_unlock(&amp;current-&gt;sighand-&gt;siglock);
    syscall_tracepoint_update(p);
    write_unlock_irq(&amp;tasklist_lock);

    if (pidfile)
        fd_install(pidfd, pidfile);

    proc_fork_connector(p);
    sched_post_fork(p);
    cgroup_post_fork(p, args);
    perf_event_fork(p);

    trace_task_newtask(p, clone_flags);
    uprobe_copy_process(p, clone_flags);

    copy_oom_score_adj(clone_flags, p);

    return p;

bad_fork_cancel_cgroup:
    sched_core_free(p);
    spin_unlock(&amp;current-&gt;sighand-&gt;siglock);
    write_unlock_irq(&amp;tasklist_lock);
    cgroup_cancel_fork(p, args);
bad_fork_put_pidfd:
    if (clone_flags &amp; CLONE_PIDFD) {
        fput(pidfile);
        put_unused_fd(pidfd);
    }
bad_fork_free_pid:
    if (pid != &amp;init_struct_pid)
        free_pid(pid);
bad_fork_cleanup_thread:
    exit_thread(p);
bad_fork_cleanup_io:
    if (p-&gt;io_context)
        exit_io_context(p);
bad_fork_cleanup_namespaces:
    exit_task_namespaces(p);
bad_fork_cleanup_mm:
    if (p-&gt;mm) {
        mm_clear_owner(p-&gt;mm, p);
        mmput(p-&gt;mm);
    }
bad_fork_cleanup_signal:
    if (!(clone_flags &amp; CLONE_THREAD))
        free_signal_struct(p-&gt;signal);
bad_fork_cleanup_sighand:
    __cleanup_sighand(p-&gt;sighand);
bad_fork_cleanup_fs:
    exit_fs(p); /* blocking */
bad_fork_cleanup_files:
    exit_files(p); /* blocking */
bad_fork_cleanup_semundo:
    exit_sem(p);
bad_fork_cleanup_security:
    security_task_free(p);
bad_fork_cleanup_audit:
    audit_free(p);
bad_fork_cleanup_perf:
    perf_event_free_task(p);
bad_fork_cleanup_policy:
    lockdep_free_task(p);
#ifdef CONFIG_NUMA
    mpol_put(p-&gt;mempolicy);
#endif
bad_fork_cleanup_delayacct:
    delayacct_tsk_free(p);
bad_fork_cleanup_count:
    dec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);
    exit_creds(p);
bad_fork_free:
    WRITE_ONCE(p-&gt;__state, TASK_DEAD);
    exit_task_stack_account(p);
    put_task_stack(p);
    delayed_free_task(p);
fork_out:
    spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);
    hlist_del_init(&amp;delayed.node);
    spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);
    return ERR_PTR(retval);
}
</code></pre>
<p>Функция <code>copy_process</code> является центральным компонентом ядра Linux, отвечающим за создание новых процессов и потоков выполнения. Она выполняет глубокую копию структуры процесса и инициализирует все необходимые ресурсы для нового процесса.</p>
<p>Функция принимает четыре основных параметра:</p>
<ul>
<li><code>struct pid *pid</code> - идентификатор процесса</li>
<li><code>int trace</code> - флаг отслеживания</li>
<li><code>int node</code> - номер узла NUMA</li>
<li><code>struct kernel_clone_args *args</code> - аргументы клонирования</li>
</ul>
<p>Возвращает указатель на структуру <code>task_struct</code> нового процесса или код ошибки.</p>
<h4 id="_18">Детальный разбор функциональности</h4>
<p>Предварительные проверки валидности</p>
<pre><code class="language-c">if ((clone_flags &amp; (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
    return ERR_PTR(-EINVAL);
</code></pre>
<ul>
<li>Проверяет корректность комбинации флагов клонирования</li>
<li>Предотвращает конфликты между различными режимами клонирования</li>
<li>Защищает от некорректных комбинаций флагов, которые могут нарушить изоляцию процессов</li>
</ul>
<p>Копирование структуры процесса</p>
<pre><code class="language-c">p = dup_task_struct(current, node);
if (!p)
    goto fork_out;
</code></pre>
<ul>
<li>Создает копию основной структуры процесса</li>
<li>Выделяет память для нового процесса</li>
<li>Инициализирует базовые поля структуры</li>
</ul>
<p>Настройка сигналов и сигнальных обработчиков</p>
<pre><code class="language-c">sigemptyset(&amp;delayed.signal);
INIT_HLIST_NODE(&amp;delayed.node);
spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);
</code></pre>
<ul>
<li>Подготавливает механизм обработки сигналов</li>
<li>Обеспечивает корректную передачу сигналов между процессами</li>
<li>Синхронизирует доступ к сигнальным структурам</li>
</ul>
<p>Инициализация ресурсов процесса</p>
<pre><code class="language-c">delayacct_tsk_init(p);
p-&gt;flags &amp;= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE | PF_NO_SETAFFINITY);
p-&gt;flags |= PF_FORKNOEXEC;
INIT_LIST_HEAD(&amp;p-&gt;children);
INIT_LIST_HEAD(&amp;p-&gt;sibling);
</code></pre>
<ul>
<li>Настраивает флаги процесса</li>
<li>Инициализирует списки потомков и братьев</li>
<li>Подготавливает структуры для учета времени</li>
</ul>
<p>Настройка планировщика</p>
<pre><code class="language-c">retval = sched_fork(clone_flags, p);
if (retval)
    goto bad_fork_cleanup_policy;
</code></pre>
<ul>
<li>Регистрирует процесс в планировщике</li>
<li>Выделяет ресурсы для планирования</li>
<li>Настраивает приоритеты и домены CPU</li>
</ul>
<p>Регистрация процесса в системе</p>
<pre><code class="language-c">write_lock_irq(&amp;tasklist_lock);
init_task_pid_links(p);
if (likely(p-&gt;pid)) {
    init_task_pid(p, PIDTYPE_PID, pid);
    if (thread_group_leader(p)) {
        init_task_pid(p, PIDTYPE_TGID, pid);
        init_task_pid(p, PIDTYPE_PGID, task_pgrp(current));
        init_task_pid(p, PIDTYPE_SID, task_session(current));
    }
}
</code></pre>
<ul>
<li>Регистрирует процесс в системных списках</li>
<li>Выделяет и устанавливает идентификаторы процесса</li>
<li>Инициализирует группы процессов и сессии</li>
</ul>
<p>Обработка ошибок и очистка</p>
<pre><code class="language-c">bad_fork_cleanup_thread:
    exit_thread(p);
bad_fork_cleanup_io:
    if (p-&gt;io_context)
        exit_io_context(p);
bad_fork_cleanup_namespaces:
    exit_task_namespaces(p);
</code></pre>
<p>Функция <code>copy_process</code> является критически важным компонентом ядра Linux, обеспечивающим создание новых процессов с соблюдением всех требований безопасности и эффективности. Она реализует сложную логику клонирования процессов, обеспечивая корректную инициализацию всех необходимых ресурсов и структур данных.</p>
<h3 id="_19">Процесс активации процесса</h3>
<pre><code class="language-c">/*
 * wake_up_new_task - wake up a newly created task for the first time.
 *
 * This function will do some initial scheduler statistics housekeeping
 * that must be done for every newly created context, then puts the task
 * on the runqueue and wakes it.
 */
void wake_up_new_task(struct task_struct *p)
{
    struct rq_flags rf;
    struct rq *rq;

    raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, rf.flags);
    WRITE_ONCE(p-&gt;__state, TASK_RUNNING);
#ifdef CONFIG_SMP
    /*
     * Fork balancing, do it here and not earlier because:
     *  - cpus_ptr can change in the fork path
     *  - any previously selected CPU might disappear through hotplug
     *
     * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq,
     * as we're not fully set-up yet.
     */
    p-&gt;recent_used_cpu = task_cpu(p);
    rseq_migrate(p);
    __set_task_cpu(p, select_task_rq(p, task_cpu(p), WF_FORK));
#endif
    rq = __task_rq_lock(p, &amp;rf);
    update_rq_clock(rq);
    post_init_entity_util_avg(p);

    activate_task(rq, p, ENQUEUE_NOCLOCK);
    trace_sched_wakeup_new(p);
    check_preempt_curr(rq, p, WF_FORK);
#ifdef CONFIG_SMP
    if (p-&gt;sched_class-&gt;task_woken) {
        /*
         * Nothing relies on rq-&gt;lock after this, so it's fine to
         * drop it.
         */
        rq_unpin_lock(rq, &amp;rf);
        p-&gt;sched_class-&gt;task_woken(rq, p);
        rq_repin_lock(rq, &amp;rf);
    }
#endif
    task_rq_unlock(rq, p, &amp;rf);
}
</code></pre>
<p>Функция принимает указатель на структуру <code>task_struct</code> нового процесса и выполняет все необходимые действия для его активации в планировщике задач. Это включает в себя:</p>
<ul>
<li>Инициализацию статистики планировщика</li>
<li>Помещение процесса в очередь выполнения</li>
<li>Подготовку к первому запуску</li>
</ul>
<h4 id="_20">Детальный разбор действий</h4>
<p>Защита от прерываний и блокировка</p>
<pre><code class="language-c">raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, rf.flags);
</code></pre>
<ul>
<li>Блокирует прерывания на текущем процессоре</li>
<li>Захватывает pi_lock для защиты от параллельного доступа</li>
<li>Сохраняет флаги прерываний для последующей восстановки</li>
</ul>
<p>Установка начального состояния</p>
<pre><code class="language-c">WRITE_ONCE(p-&gt;__state, TASK_RUNNING);
</code></pre>
<ul>
<li>Устанавливает процесс в состояние готовности к выполнению</li>
<li>Использует WRITE_ONCE для гарантии видимости изменения всем процессорам</li>
</ul>
<p>Балансировка нагрузки (CONFIG_SMP)</p>
<pre><code class="language-c">#ifdef CONFIG_SMP
p-&gt;recent_used_cpu = task_cpu(p);
rseq_migrate(p);
__set_task_cpu(p, select_task_rq(p, task_cpu(p), WF_FORK));
</code></pre>
<ul>
<li>Выполняется только на SMP-системах</li>
<li>Выбирает оптимальный процессор для выполнения</li>
<li>Обеспечивает балансировку нагрузки между ядрами</li>
</ul>
<p>Обновление статистики планировщика</p>
<pre><code class="language-c">rq = __task_rq_lock(p, &amp;rf);
update_rq_clock(rq);
post_init_entity_util_avg(p);
</code></pre>
<ul>
<li>Блокирует очередь выполнения (runqueue)</li>
<li>Обновляет временные метки планировщика</li>
<li>Инициализирует статистику использования CPU</li>
</ul>
<p>Активация задачи</p>
<pre><code class="language-c">activate_task(rq, p, ENQUEUE_NOCLOCK);
trace_sched_wakeup_new(p);
check_preempt_curr(rq, p, WF_FORK);
</code></pre>
<ul>
<li>Добавляет процесс в очередь выполнения</li>
<li>Регистрирует событие активации для отладки</li>
<li>Проверяет необходимость немедленного переключения контекста</li>
</ul>
<p>Завершение и освобождение ресурсов</p>
<pre><code class="language-c">#ifdef CONFIG_SMP
if (p-&gt;sched_class-&gt;task_woken) {
    rq_unpin_lock(rq, &amp;rf);
    p-&gt;sched_class-&gt;task_woken(rq, p);
    rq_repin_lock(rq, &amp;rf);
}
#endif
task_rq_unlock(rq, p, &amp;rf);
</code></pre>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
